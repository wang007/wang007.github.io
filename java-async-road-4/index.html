<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="零上一篇文章简单介绍了响应式编程的概念和具体的实现Project Reactor以及响应式流规范定义的所有接口。这篇文章将深入内部探究Project Reactor实现原理。实际上Project Reactor实现方式和代码风格跟Rxjava非常相似，所以理解了Project Reactor内部的运行原理，那么Rxjava也八九不离十了。而且Rxjava除了Flowable之外都是没背压的，所以实">
<meta property="og:type" content="article">
<meta property="og:title" content="java异步编程探究-Project Reactor实现原理">
<meta property="og:url" content="http://example.com/java-async-road-4/index.html">
<meta property="og:site_name" content="wang007 blog">
<meta property="og:description" content="零上一篇文章简单介绍了响应式编程的概念和具体的实现Project Reactor以及响应式流规范定义的所有接口。这篇文章将深入内部探究Project Reactor实现原理。实际上Project Reactor实现方式和代码风格跟Rxjava非常相似，所以理解了Project Reactor内部的运行原理，那么Rxjava也八九不离十了。而且Rxjava除了Flowable之外都是没背压的，所以实">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/java-async-road-4/nengyongjiuxing.jpg">
<meta property="og:image" content="http://example.com/java-async-road-4/mono-def.jpg">
<meta property="og:image" content="http://example.com/java-async-road-4/subscriber.jpg">
<meta property="og:image" content="http://example.com/java-async-road-4/onSubscribe.jpg">
<meta property="og:image" content="http://example.com/java-async-road-4/MonoJust.png">
<meta property="og:image" content="http://example.com/java-async-road-4/MonoMap.png">
<meta property="og:image" content="http://example.com/java-async-road-4/MonoFlatMap.png">
<meta property="article:published_time" content="2019-12-24T14:56:09.000Z">
<meta property="article:modified_time" content="2021-01-01T17:44:10.391Z">
<meta property="article:author" content="wang007">
<meta property="article:tag" content="java">
<meta property="article:tag" content="异步">
<meta property="article:tag" content="reactive">
<meta property="article:tag" content="Project Reactor">
<meta property="article:tag" content="响应式编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/java-async-road-4/nengyongjiuxing.jpg">


<link rel="canonical" href="http://example.com/java-async-road-4/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java异步编程探究-Project Reactor实现原理 | wang007 blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">wang007 blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6"><span class="nav-number">1.</span> <span class="nav-text">零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A3%E6%96%87"><span class="nav-number">2.</span> <span class="nav-text">正文</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E9%98%B6%E6%AE%B5"><span class="nav-number">2.1.</span> <span class="nav-text">定义阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A2%E9%98%85%E9%98%B6%E6%AE%B5"><span class="nav-number">2.2.</span> <span class="nav-text">订阅阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#onSubscribe%E9%98%B6%E6%AE%B5"><span class="nav-number">2.3.</span> <span class="nav-text">onSubscribe阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E5%B0%84%E6%95%B0%E6%8D%AE%E9%98%B6%E6%AE%B5"><span class="nav-number">2.4.</span> <span class="nav-text">发射数据阶段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mono"><span class="nav-number">3.</span> <span class="nav-text">Mono</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAMono"><span class="nav-number">3.1.</span> <span class="nav-text">创建Mono</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.2.</span> <span class="nav-text">map操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InternalMonoOperator%E6%80%8E%E4%B9%88%E6%8A%8A%E9%80%92%E5%BD%92%E5%8F%98%E5%BE%AA%E7%8E%AF%E7%9A%84%EF%BC%9F"><span class="nav-number">3.3.</span> <span class="nav-text">InternalMonoOperator怎么把递归变循环的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FlatMap"><span class="nav-number">3.4.</span> <span class="nav-text">FlatMap</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wang007</p>
  <div class="site-description" itemprop="description">wang007 blog</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/java-async-road-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wang007">
      <meta itemprop="description" content="wang007 blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wang007 blog">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java异步编程探究-Project Reactor实现原理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-24 22:56:09" itemprop="dateCreated datePublished" datetime="2019-12-24T22:56:09+08:00">2019-12-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-02 01:44:10" itemprop="dateModified" datetime="2021-01-02T01:44:10+08:00">2021-01-02</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/%E5%BC%82%E6%AD%A5/" itemprop="url" rel="index"><span itemprop="name">异步</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/%E5%BC%82%E6%AD%A5/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">响应式编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/%E5%BC%82%E6%AD%A5/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/reactive/" itemprop="url" rel="index"><span itemprop="name">reactive</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="零"><a href="#零" class="headerlink" title="零"></a>零</h2><p>上一篇文章简单介绍了响应式编程的概念和具体的实现<a target="_blank" rel="noopener" href="https://projectreactor.io/">Project Reactor</a>以及<a href="www.reactive-streams.org">响应式流</a>规范定义的所有接口。<br>这篇文章将深入内部探究Project Reactor实现原理。实际上Project Reactor实现方式和代码风格跟Rxjava非常相似，所以理解了Project Reactor内部的运行原理，那么Rxjava也八九不离十了。而且Rxjava除了Flowable之外都是没背压的，所以实现上总体会简单一点。</p>
<a id="more"></a>

<p>名字解释：</p>
<ul>
<li>数据源：例如MonoJust（即Mono#just方法）、MonoDefer（即Mono#defer方法）等等。</li>
<li>操作符：例如map、flatMap等等。即创建好实例之后调用的所有对数据源进行操作的方法。</li>
<li>上游：  例如Mono.just(“s”).map(s -&gt; s).flatMap() just是map的上游， map操作符是flatMap的上游。</li>
<li>下游：  跟下游相反。上例map是just的下游，flatMap是map的下游。</li>
</ul>
<p>这里说个看源码的小技巧。</p>
<ul>
<li>先熟悉一下api和使用方式，然后自己脑子里先构思一下怎么实现的，想不出来没关系，带着问题看源码。</li>
<li>把头拎出来， 这个头一般是核心接口和类。</li>
<li>先简单后复杂。先梳理简单的实现，好对这个概念有一定的理解，最后再梳理复杂的实现。</li>
<li>顺着主流程脉络往下走，可以忽略次流程。待主流程理解了之后，再选择性看次流程。</li>
</ul>
<p>或者你有比较好的技巧也可以。千万别干撸，不然很容易就怀疑人生。<br><img src="/java-async-road-4/nengyongjiuxing.jpg"></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>先从上篇文章举的例子作为这次源码分析主流程。<br>因为Mono发射0|1个数据，所以内部实现会稍微简单一点。先简单分析一下Mono，然后再深入Flux。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Mono.just(<span class="string">&quot;name&quot;</span>)                       <span class="comment">//创建发射单个数据的数据源Mono</span></span><br><span class="line">    .map(str -&gt; str + <span class="string">&quot;: wang007&quot;</span>)      <span class="comment">//对数据进行转换</span></span><br><span class="line">    .flatMap(str -&gt; &#123;                   <span class="comment">//平铺</span></span><br><span class="line">        System.out.println(<span class="string">&quot;str -&gt; &quot;</span> + str);</span><br><span class="line">        <span class="keyword">return</span> Mono.just(str.length());</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(len -&gt; len + <span class="string">&quot;&quot;</span> + len)                <span class="comment">//再转换，转换成String的长度</span></span><br><span class="line">    .filter(lenStr -&gt; lenStr.length() &gt; <span class="number">5</span>)     <span class="comment">//过滤</span></span><br><span class="line">    .subscribe(str -&gt; &#123;                        <span class="comment">//订阅</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result -&gt; &quot;</span> + str);</span><br><span class="line">    &#125;, err -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;onError&quot;</span>);</span><br><span class="line">        err.printStackTrace();</span><br><span class="line">    &#125;, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;onComplete&quot;</span>);</span><br><span class="line">    &#125;, subscription -&gt; subscription.request(Long.MAX_VALUE));</span><br></pre></td></tr></table></figure>
<p>1 Mono就是Reactive Stream规范的Publisher<br>2 subscribe方法中的几个lambda表达式作为会组成Subscriber</p>
<p>在使用Mono|Flux主要有4个过程</p>
<ol>
<li>定义阶段。上面的just、map、flatMap等方法</li>
<li>订阅阶段。上面的subscribe方法</li>
<li>onSubscribe阶段。上面subscribe方法最后一个lambda表达式:subscription-&gt;subscription.request(Long.MAX_VALUE)</li>
<li>发射数据。 数据会从just方法内部开始往下游流动。记住：数据并不是线性流动的。先遇到flatMap，concatMap等这类操作一般是未完成的结果时，所以内部表象是流动到flatMap时好像是突然停了，待flatMap结果真正完成时，数据又从flatMap开始往下游流动</li>
</ol>
<h3 id="定义阶段"><a href="#定义阶段" class="headerlink" title="定义阶段"></a>定义阶段</h3><p>实际上，Mono|Flux中每个操作符都会创建一个新的Mono|Flux，并把原来的Mono|Flux包裹在里面。像极了俄罗斯套娃。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Mono&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Fuseable) &#123;</span><br><span class="line">		<span class="keyword">return</span> onAssembly(<span class="keyword">new</span> MonoMapFuseable&lt;&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> onAssembly(<span class="keyword">new</span> MonoMap&lt;&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Mono&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Mono&lt;? extends R&gt;&gt; transformer)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> onAssembly(<span class="keyword">new</span> MonoFlatMap&lt;&gt;(<span class="keyword">this</span>, transformer));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以整个定义过程就是<br><img src="/java-async-road-4/mono-def.jpg" alt="Mono的定义过程"><br>这些对象Mono的子类，除了MonoJust，其他的MonoMap、MonoFlatMap等内部一般都有一个source属性保存自己的直属上游。</p>
<h3 id="订阅阶段"><a href="#订阅阶段" class="headerlink" title="订阅阶段"></a>订阅阶段</h3><p>上面的subscribe方法中lambda表达式会组成一个Subscriber的实现：<strong>reactor.core.publisher.LambdaMonoSubscriber</strong><br>然后这个subscriber会一直往上游层层包装，一直到MonoJust。这个也像是俄罗斯套娃。<br>所以整个订阅过程就是<br><img src="/java-async-road-4/subscriber.jpg" alt="Mono的订阅过程"></p>
<ol>
<li>subscribe方法中生成subscriber传入MonoFilter中</li>
<li>在MonoFilter中，把Subscriber包装成FilterSubscriber传入MonoMap中</li>
<li>在MonoMap中，把FilterSubscriber包装成MapSubscriber传入MonoFlatMap中。</li>
<li>在MonoFlatMap中，把MapSubscriber包装成FlatMapSubscriber传入MonoMap中。</li>
<li>在MonoMap中，把FlatMapSubscriber包装成MapSubscriber传入MonoJust中。</li>
<li>而MonoJust是真正的Mono Source。所以MonoJust会生成Subscription触发下一个阶段（onSubscribe阶段）</li>
</ol>
<p>所以订阅阶段会把最原始的Subscriber层层包装往上游传递。所以外层包装的Subscriber会持有下游Subscriber的引用。这个引用在Project Reactor源码中一般叫<strong>actual</strong></p>
<h3 id="onSubscribe阶段"><a href="#onSubscribe阶段" class="headerlink" title="onSubscribe阶段"></a>onSubscribe阶段</h3><p>由订阅阶段分析得知Subscriber层层包装往上游传递最后到了MonoJust。MonoJust会生成Subscription往下游传递，这个Subscription就是在Reactive Stream规范中定义的，代表Publisher与Subscriber关系的对象。</p>
<ol>
<li>一般情况下操作符内的Subscriber一般也会定义成Subscription（通过继承），然后包装上游传下来的Subscription保存起来，再把自己往下游传，最后到subscribe方法定义的Subscriber对象中。</li>
<li>然后在自定义的Subscriber#onSubscribe方法中通过调用Subscription#request请求多少数据。</li>
<li>最终request请求方法还是会到MonoJust中。</li>
</ol>
<p>所以整个onSubscribe过程就是<br><img src="/java-async-road-4/onSubscribe.jpg" alt="Mono的订阅过程"></p>
<p>所以这个阶段已经看的出来，这个像极了管道。所以下面我会用操作符管道：表示这个一系列操作符组成的Mono|Flux。</p>
<ol>
<li>定义阶段就是铺好这个管道。</li>
<li>订阅阶段就是疏通这个管道。</li>
<li>onSubscribe和发射数据阶段就是信息和数据在这个管道中流通，而上游发射多少数据是由下游控制的。</li>
</ol>
<h3 id="发射数据阶段"><a href="#发射数据阶段" class="headerlink" title="发射数据阶段"></a>发射数据阶段</h3><p>经过前3个阶段铺垫，那么这个阶段就比较简单了，直接在onSubscribe方法调用Subscription#request方法请求多少数据。<br>最后数据呈现在Subscriber对象中的onNext方法中。</p>
<hr>
<p>通过上面的讲解，对Project Reactor运行原理有个大概的认识。现在就深入到内部，详细探究它的实现原理。<br>先分析核心接口，这些在Mono|Flux都是共用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoreSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> Context <span class="title">currentContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Context.empty();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CorePublisher</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Publisher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>CoreSubscriber继承自Reactive Stream中的Subscriber。主要是提供了currentContext方法用于获取Context。<br>Context跟Map差不多，直接简单理解成Map都没问题，主要区别是Context是不可变的（Immutable）而且线程安全的（废话，Immutable已经包含线程安全的语义了）。<br>Context主要保存一些用户自定义可选的的行为。例如数据在操作符管道中处理发生异常，如果在Context保存了对异常处理的hook方法，那么就调用hook方法处理。</p>
</li>
<li><p>CorePublisher继承自Reactive Stream中的Publisher。主要是代表订阅时使用CoreSubscriber，而非Subscriber。<br>在内部实现中，都是使用CoreSubscriber、CorePublisher，而不是直接使用Subscriber、Publisher。 例如Mono|Flux继承CorePublisher。</p>
</li>
</ol>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口代表一个可处理的资源。这个名字定义的太抽象了。<br>一般情况下，dispose方法就是取消这个资源，此方法必须保证幂等。 isDisposed方法就是判断是否已经取消 或者 完成。（取消或正常完成都返回true）<br>例如Mono|Flux subscribe方法返回一个Disposable。可以调用dispose取消发射数据。而调用isDisposed方法判断该Disposable锁代表的Mono|Flux是否已经取消发射数据或正常发射完所有的数据了。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fuseable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//融合请求是下游向上游请求的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不支持融合，用于下游请求上游融合时，上游不支持下游声明的融合模式</span></span><br><span class="line">    <span class="keyword">int</span> NONE = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同步融合。下游请求上游融合时声明同步融合模式，</span></span><br><span class="line">    <span class="comment">//如果上游支持同步融合模式，那么返回该值代表支持同步融合，否则返回NONE。</span></span><br><span class="line">    <span class="keyword">int</span> SYNC = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//异步融合。下游请求上游融合时声明异步融合模式，</span></span><br><span class="line">    <span class="comment">//如果上游支持异步融合模式，那么返回该值代表支持异步融合，否则返回NONE。</span></span><br><span class="line">    <span class="keyword">int</span> ASYNC = <span class="number">2</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//同步或异步融合。用于下游请求上游融合时声明ANY融合模式。</span></span><br><span class="line">    <span class="comment">//如果上游支持同步融合模式，那么返回SYNC。</span></span><br><span class="line">    <span class="comment">//如果上游支持异步融合模式，那么返回ASYNC。</span></span><br><span class="line">    <span class="comment">//如果上游不支持融合，则返回NONE。</span></span><br><span class="line">    <span class="comment">//切记：ANY只能用于下游请求上游融合的入参，不能作为返回参数。</span></span><br><span class="line">    <span class="keyword">int</span> ANY = <span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//代表能否支持跨线程融合。跨线程指下游要跨线程，例如下游操作符为publishOn。该参数配合SYNC|ASYNC|ANY任一使用才有用。</span></span><br><span class="line">    <span class="keyword">int</span> THREAD_BARRIER = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口是非常重要的，该接口也只是个标记型接口，用于描述Mono|Flux是否可融合的。上面分析得知，每个操作符都会产生新的Mono|Flux对象。<br>Mono|Flux还只是个抽象类，具体像MonoJust、MonoMap、MonoFlatMap（这些对象调用操作符方法产生）等才是真正的实现，这些实现类是否继承Fuseable来表示是否可融合的Mono|Flux。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fuseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">QueueSubscription</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">T</span>&gt;, <span class="title">Subscription</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">requestFusion</span><span class="params">(<span class="keyword">int</span> requestedMode)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//省略一些无关紧要的方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现了Fuseable接口的Mono|Flux，执行下游的onSubscribe方法时，入参的Subscription一定是QueueSubscription类型的。因为这个入参的Subscription是上游传下来的，那么调用requestFusion方法实际上就是对上游请求融合，入参requestedMode就是SYNC|ASYNC|ANY之一或再与上THREAD_BARRIER。例如：AYNC|THREAD_BARRIER。（|是与运算，非文字表达或的意思）</p>
<p>同步融合: 见名知其意，支持同步融合的上游。同步融合的上游的数据一定是全部准备好的了，可直接拉取Queue#poll。如果poll方法返回null，则上游数据处理完了。所以同步融合模式上游不再调用下游onComplete方法。</p>
<p>异步融合：支持同步融合的上游，异步融合的上游数据不一定是准备好的了。当上游数据准备好，通过onNext方法通知下游数据已经准备好了，下游直接拉取Queue#poll。如果poll方法返回null，上游并不一定处理完了，可能只是暂时没数据了，上游处理完了一定会通过onComplete方法通知下游，这点跟同步融合区别很大。</p>
<p>为什么需要融合呢？</p>
<blockquote>
<p>如果不支持融合的Mono|Flux，那么上游发射的数据都是通过onNext方法一个一个往下游传的。支持融合的话，下游可以一次拉取N个数据，一起处理。<br>如果下游操作符开销比较大的话，那么支持融合的Mono|Flux就能有效提升性能。<br>例如：publishOn操作符，上游每发射一个数据，它都需要切换到指定的线程池上。如果融合的话，那么直接在指定的线程池上执行拉取数据。这样就可以N个数据对应一个线程池任务了。如果没理解，没关系，下面会继续深入分析。</p>
</blockquote>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Scannable</span> </span>&#123;</span><br><span class="line">	<span class="function">Object <span class="title">scanUnsafe</span><span class="params">(Attr key)</span></span>;</span><br><span class="line">	<span class="comment">//省略若干代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口通过scanUnsafe方法导出内部的状态，而且入参Attr一般是已经预定义好的值，在Scannable中定义。例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MonoJust</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Mono</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Fuseable</span>.<span class="title">ScalarCallable</span>&lt;<span class="title">T</span>&gt;, <span class="title">Fuseable</span>, <span class="title">SourceProducer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">scanUnsafe</span><span class="params">(Attr key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (key == Attr.BUFFERED) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示MonoJust支持导出内部队列的容量大小。Scannable属于次流程接口了，可不深入了解也行。</p>
<hr>
<p>Scheduler：用于调度操作符执行在某一线程池上，熟悉Rxjava的朋友一定很熟悉这个接口了。</p>
<blockquote>
<p>一些操作符内部本身就是要依赖Scheduler才能实现的，这些情况一定要明白，不然在一些线程敏感的应用容易出问题。例如timeout操作符、delay相关的操作符等。<br>也就是说这些操作符在哪个线程池调度有个清晰的认识。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Scheduler</span> <span class="keyword">extends</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//往调度器中提交任务，相当于Executor#submit方法</span></span><br><span class="line">	<span class="function">Disposable <span class="title">schedule</span><span class="params">(Runnable task)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//往调度器中提交延时任务，相当于ScheduledExecutorService#schedule方法	</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Disposable <span class="title">schedule</span><span class="params">(Runnable task, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> Exceptions.failWithRejectedNotTimeCapable();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//往调度器中提交周期性任务，相当于ScheduledExecutorService#scheduleAtFixedRate方法</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Disposable <span class="title">schedulePeriodically</span><span class="params">(Runnable task, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> Exceptions.failWithRejectedNotTimeCapable();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略now方法</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function">Worker <span class="title">createWorker</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭调度器</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//启动调度器</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Work，实现上也是把任务提交给Scheduler执行。</span></span><br><span class="line">	<span class="comment">//但是区别在于关闭Worker（dispose方法）的时候，可以把Work中所有正在执行的任务全部取消掉。</span></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">		<span class="comment">//跟Scheduler一样</span></span><br><span class="line">		<span class="function">Disposable <span class="title">schedule</span><span class="params">(Runnable task)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//跟Scheduler一样</span></span><br><span class="line">		<span class="function"><span class="keyword">default</span> Disposable <span class="title">schedule</span><span class="params">(Runnable task, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> Exceptions.failWithRejectedNotTimeCapable();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//跟Scheduler一样</span></span><br><span class="line">		<span class="function"><span class="keyword">default</span> Disposable <span class="title">schedulePeriodically</span><span class="params">(Runnable task, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> Exceptions.failWithRejectedNotTimeCapable();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，Project Reactor内部自带Scheduler的实现，也是把任务提交给Scheduler内部的ScheduledExecutorService执行，所以你把Scheduler理解成ScheduledExecutorService线程池，完全没有问题。</p>
<blockquote>
<p>这里先挖个坑，ScheduledExecutorService是不适合做任务线程池的，它只适合做定时任务线程池的。如果ScheduledExecutorService用于跑大量非定时任务的话是非常不适合的。下次开个专题专门说说线程池的那些事。</p>
</blockquote>
<hr>
<h2 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h2><blockquote>
<p>还是按照上面例子中的操作符讲，操作符非常多，不可能把所有操作符的实现都讲一遍，主要讲一些常用的、或者容易引起疑惑的。<br>笔者之前使用Rxjava使用最频繁就是flatMap、map，其次是timeout、zip、concatMap、filter，其他就比较少了。<br>observeOn（Project Reactor叫publishOn)与subscribeOn是最容易混淆的。</p>
</blockquote>
<h3 id="创建Mono"><a href="#创建Mono" class="headerlink" title="创建Mono"></a>创建Mono</h3><p>最常用的还是Mono#just（MonoJust），还有Mono#create（MonoCreate）<br><img src="/java-async-road-4/MonoJust.png" alt="图片来源reactivex.io"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Mono只继承了CorePublisher，未继承Fuseable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mono</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CorePublisher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//just new MonoJust实例并返回</span></span><br><span class="line">	<span class="comment">//onAssembly用于执行一些用户自定义的hook函数，这个不重要。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Mono&lt;T&gt; <span class="title">just</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> onAssembly(<span class="keyword">new</span> MonoJust&lt;&gt;(data));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//省略若干代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MonoJust继承了Fuseable，所以MonoJust是支持融合的。</span></span><br><span class="line"><span class="comment">//ScalarCallable是Callable的标记型接口，代表可立即产生一条数据的source</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MonoJust</span>&lt;<span class="title">T</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Mono</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Fuseable</span>.<span class="title">ScalarCallable</span>&lt;<span class="title">T</span>&gt;, <span class="title">Fuseable</span>, <span class="title">SourceProducer</span>&lt;<span class="title">T</span>&gt;  </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> T value;</span><br><span class="line">  </span><br><span class="line">	MonoJust(T value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.value = Objects.requireNonNull(value, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; actual)</span> </span>&#123;</span><br><span class="line">		actual.onSubscribe(Operators.scalarSubscription(actual, value));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//省略若干代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MonoJust代码的关键在于subscribe方法内，先调用Operators#scalarSubscription方法生成subscription，</span></span><br><span class="line"><span class="comment">//然后执行下游的onSubscribe方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也只是创建个ScalarSubscription</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">scalarSubscription</span><span class="params">(CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, T value)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ScalarSubscription&lt;&gt;(subscriber, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ScalarSubscription继承 SynchronousSubscription</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//支持同步融合的QueueSubscription</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SynchronousSubscription</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">QueueSubscription</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">requestFusion</span><span class="params">(<span class="keyword">int</span> requestedMode)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> ((requestedMode &amp; Fuseable.SYNC) != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> Fuseable.SYNC;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> NONE;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MonoJust支持融合，所以MonoJust创建的Subscription也一定QueueSubscription</span></span><br><span class="line"><span class="comment">//而这个QueueSubscription也是只有一条数据的Queue</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarSubscription</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">			<span class="keyword">implements</span> <span class="title">Fuseable</span>.<span class="title">SynchronousSubscription</span>&lt;<span class="title">T</span>&gt;, <span class="title">InnerProducer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; actual; <span class="comment">//下游Subscriber</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//0.未消费 1. 已消费， 2.已取消</span></span><br><span class="line">		<span class="keyword">volatile</span> <span class="keyword">int</span> once;</span><br><span class="line">		ScalarSubscription(CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; actual, T value) &#123;</span><br><span class="line">			<span class="keyword">this</span>.value = Objects.requireNonNull(value, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">			<span class="keyword">this</span>.actual = Objects.requireNonNull(actual, <span class="string">&quot;actual&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (once == <span class="number">0</span>) &#123; <span class="comment">//这里代表数据未消费就直接丢掉，如果有hook方法就执行hook方法。</span></span><br><span class="line">				<span class="comment">//前面提到Context说到，会从Context取一些hook方法来执行，取不到就忽略。</span></span><br><span class="line">				Operators.onDiscard(value, actual.currentContext());  </span><br><span class="line">			&#125;</span><br><span class="line">			ONCE.lazySet(<span class="keyword">this</span>, <span class="number">2</span>); <span class="comment">//取消</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Queue接口方法，清除数据</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (once == <span class="number">0</span>) &#123;</span><br><span class="line">				Operators.onDiscard(value, actual.currentContext());</span><br><span class="line">			&#125;</span><br><span class="line">			ONCE.lazySet(<span class="keyword">this</span>, <span class="number">1</span>); <span class="comment">//置消费位，代表已清空队列</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> once != <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; actual() &#123;</span><br><span class="line">			<span class="keyword">return</span> actual;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//拉取数据，并设置已消费。</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (once == <span class="number">0</span>) &#123;</span><br><span class="line">				ONCE.lazySet(<span class="keyword">this</span>, <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">return</span> value;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="meta">@Nullable</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> Object <span class="title">scanUnsafe</span><span class="params">(Attr key)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (key == Attr.TERMINATED || key == Attr.CANCELLED)</span><br><span class="line">				<span class="keyword">return</span> once == <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> InnerProducer.<span class="keyword">super</span>.scanUnsafe(key);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (validate(n)) &#123; <span class="comment">//校验n &gt; 0</span></span><br><span class="line">				<span class="keyword">if</span> (ONCE.compareAndSet(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">1</span>)) &#123; <span class="comment">//竟态条件，CAS。</span></span><br><span class="line">					Subscriber&lt;? <span class="keyword">super</span> T&gt; a = actual; <span class="comment">//下游</span></span><br><span class="line">					a.onNext(value); <span class="comment">//调用通知下游</span></span><br><span class="line">					<span class="keyword">if</span>(once != <span class="number">2</span>) &#123; <span class="comment">//没有取消的话，调用下游的onComplete方法</span></span><br><span class="line">						a.onComplete(); </span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">requestFusion</span><span class="params">(<span class="keyword">int</span> requestedMode)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> ((requestedMode &amp; Fuseable.SYNC) != <span class="number">0</span>) &#123; <span class="comment">//请求包含同步融合，那么就支持同步融合。</span></span><br><span class="line">				<span class="keyword">return</span> Fuseable.SYNC;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//NONE,不支持融合</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> isEmpty() ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;ScalarSubscription&gt; ONCE =</span><br><span class="line">				AtomicIntegerFieldUpdater.newUpdater(ScalarSubscription.class, <span class="string">&quot;once&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在MonoJust#subscribe方法内，调用下游（actual）#onSubscribe方法，把创建的ScalarSubscription实例往下游传。</li>
<li>下游在onSubscribe方法中，有两种处理方式<ol>
<li>调用request方法，那么上游就会执行下游的onNext，onComplete方法。</li>
<li>调用requestFusion方法请求融合。</li>
</ol>
</li>
</ol>
<p>融合情况分3种</p>
<ol>
<li>同步融合成功，那么不需要调用request方法请求发射数据。</li>
<li>异步融合成功，那么需要调用request方法通知上游在数据准备好时，通过onNext方法发送通知。当然MonJust不支持这模式。</li>
<li>融合失败，按照传统发射数据的方式处理。</li>
</ol>
<p>当然还有很多创建Mono实例的方式，这里不再一一列举了。</p>
<hr>
<h3 id="map操作符"><a href="#map操作符" class="headerlink" title="map操作符"></a>map操作符</h3><p><img src="/java-async-road-4/MonoMap.png" alt="图片来源reactivex.io"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mono</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CorePublisher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//还是创建一个Mono实例，并把原来的（this）给包装进去</span></span><br><span class="line">	<span class="comment">//首先判断是否支持融合的，支持融合使用MonoMapFuseable，不支持融合MonoMap</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Mono&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Fuseable) &#123;</span><br><span class="line">			<span class="keyword">return</span> onAssembly(<span class="keyword">new</span> MonoMapFuseable&lt;&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> onAssembly(<span class="keyword">new</span> MonoMap&lt;&gt;(<span class="keyword">this</span>, mapper));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MonoMapFuseable功能会包括MonoMap的，所以只讲支持融合的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很明显这个MonoMapFuseable自身也是可融合的</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MonoMapFuseable</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">InternalMonoOperator</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">Fuseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper;</span><br><span class="line"></span><br><span class="line">	MonoMapFuseable(Mono&lt;? extends T&gt; source, Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper) &#123;</span><br><span class="line">		<span class="keyword">super</span>(source);</span><br><span class="line">		<span class="keyword">this</span>.mapper = Objects.requireNonNull(mapper, <span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; subscribeOrReturn(CoreSubscriber&lt;? <span class="keyword">super</span> R&gt; actual) &#123;</span><br><span class="line">		<span class="keyword">if</span> (actual <span class="keyword">instanceof</span> ConditionalSubscriber) &#123;</span><br><span class="line">			ConditionalSubscriber&lt;? <span class="keyword">super</span> R&gt; cs = (ConditionalSubscriber&lt;? <span class="keyword">super</span> R&gt;) actual;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> FluxMapFuseable.MapFuseableConditionalSubscriber&lt;&gt;(cs, mapper);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> FluxMapFuseable.MapFuseableSubscriber&lt;&gt;(actual, mapper);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fuseable</span> </span>&#123;</span><br><span class="line">	<span class="comment">//也是Subscriber一种，其中的奥秘到tryOnNext方法中</span></span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">ConditionalSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">CoreSubscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">		<span class="comment">//是否消费数据成功，true: request数 + 1，false：request数。</span></span><br><span class="line">		<span class="comment">//例如：request(1)时，如果返回true，此时停止发射数据。如果返回false，将继续发射数据，直到返回true或数据全部发射完毕。</span></span><br><span class="line">		<span class="function"><span class="keyword">boolean</span> <span class="title">tryOnNext</span><span class="params">(T t)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConditionalSubscriber主要得看上游支不支持，这个是非主流程。下面分析还是以支持融合的操作符为主线。</p>
<blockquote>
<p>ConditionalSubscriber操作符一般用在过滤数据型操作符会很常用，例如filter操作符。<br>例如你request(1)时，在onNext方法做统计并触发下一次的request时，由于过滤过滤掉数据了，从而不会触发onNext方法且你又无从得知，所以后续的数据不会再发射出来。</p>
</blockquote>
<p>所以project Reactor有两种处理方式</p>
<ol>
<li>filter操作符在subscribe方法都会把下游包装成ConditionalSubscriber往上游传，从而避免了例子中的情况。</li>
<li>当过滤掉一条数据时，filter操作符必须得向上游再调用request(1)，把丢掉的请求量加回去。</li>
</ol>
<blockquote>
<p>为什么Rxjava2的Observable没有这个问题呢？这里留个思考题</p>
</blockquote>
<p>MonoMapFuseable继承自InternalMonoOperator，而这个InternalMonoOperator是所有Mono操作符的父类。里面主要实现了一些订阅的逻辑。</p>
<blockquote>
<p>这里为什么还需要搞InternalMonoOperator呢？<br>实际上，只需要把下游的Subscriber包装自身操作符的Subscriber，然后再执行上游(source)的subscribe方法，就可以一直往上游传递直到发射源（例如MonoJust）。例如Rxjava2就是这么做的。<br>很明显上述的做法算是一种递归。<br>InternalMonoOperator就是把递归变换成while循环，这种优化算是很用心了。</p>
</blockquote>
<h3 id="InternalMonoOperator怎么把递归变循环的？"><a href="#InternalMonoOperator怎么把递归变循环的？" class="headerlink" title="InternalMonoOperator怎么把递归变循环的？"></a>InternalMonoOperator怎么把递归变循环的？</h3><p>分析InternalMonoOperator之前先看它的父接口OptimizableOperator，这个父接口是Mono|Flux 操作符共用的，也就是说Flux也有个类似InternalMonoOperator的接口: InternalFluxOperator。<br>两者功能是一样的，分析其中之一即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很明显OptimizableOperator也是数据源的一种</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">OptimizableOperator</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">CorePublisher</span>&lt;<span class="title">IN</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子类操作符的核心业务主要是在这实现的</span></span><br><span class="line">	<span class="comment">//入参actual是下游，包装成本操作符的Subscriber并返回</span></span><br><span class="line">	<span class="comment">//返回null，代表该方法内已经处理了订阅。</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	CoreSubscriber&lt;? <span class="keyword">super</span> OUT&gt; subscribeOrReturn(CoreSubscriber&lt;? <span class="keyword">super</span> IN&gt; actual);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//上游</span></span><br><span class="line">	CorePublisher&lt;? extends OUT&gt; source();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//优化过的上游，也就是上游类继承了OptimizableOperator。 </span></span><br><span class="line">	<span class="comment">//实际上所有的操作符都会直接或间接继承OptimizableOperator，但是数据源不会。（例如：MonoJust）</span></span><br><span class="line">	<span class="comment">//所以该方法返回null，代表已经达到数据源头了。</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	OptimizableOperator&lt;?, ? extends OUT&gt; nextOptimizableSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>绝大多数情况下，source方法返回值跟nextOptimizableSource方法返回值一样，除了数据源头开始的第一个操作符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MonoOperator也是一种Mono</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalMonoOperator</span>&lt;<span class="title">I</span>, <span class="title">O</span>&gt; <span class="keyword">extends</span> <span class="title">MonoOperator</span>&lt;<span class="title">I</span>, <span class="title">O</span>&gt; <span class="keyword">implements</span> <span class="title">Scannable</span>,</span></span><br><span class="line"><span class="class">                                                                                <span class="title">OptimizableOperator</span>&lt;<span class="title">O</span>, <span class="title">I</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">final</span> OptimizableOperator&lt;?, I&gt; optimizableOperator;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">InternalMonoOperator</span><span class="params">(Mono&lt;? extends I&gt; source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(source); <span class="comment">//保存上游引用。</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//上游是否被优化过的，也就是说上游是否为操作符。</span></span><br><span class="line">		<span class="keyword">this</span>.optimizableOperator = source <span class="keyword">instanceof</span> OptimizableOperator ? (OptimizableOperator) source : <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里是递归变换成while循环的关键代码。</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(CoreSubscriber&lt;? <span class="keyword">super</span> O&gt; subscriber)</span> </span>&#123;</span><br><span class="line">		OptimizableOperator operator = <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			subscriber = operator.subscribeOrReturn(subscriber); <span class="comment">//包装下游的Subscriber</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//在subscribeOrReturn已经处理了订阅上游，直接return就行了</span></span><br><span class="line">			<span class="keyword">if</span> (subscriber == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// null means &quot;I will subscribe myself&quot;, returning...</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//取上游操作符，然后又while块的第一行，用包装后的subscriber订阅上游</span></span><br><span class="line">			OptimizableOperator newSource = operator.nextOptimizableSource();</span><br><span class="line">			<span class="keyword">if</span> (newSource == <span class="keyword">null</span>) &#123; <span class="comment">//达到数据源了，直接订阅</span></span><br><span class="line">				operator.source().subscribe(subscriber);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			operator = newSource;  <span class="comment">//把上游操作符赋值给operator，继续往上游包装subscriber。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//子类实现包装下游的Subscriber</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> CoreSubscriber&lt;? <span class="keyword">super</span> I&gt; subscribeOrReturn(CoreSubscriber&lt;? <span class="keyword">super</span> O&gt; actual);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//构造方法中赋值</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> CorePublisher&lt;? extends I&gt; source() &#123;</span><br><span class="line">		<span class="keyword">return</span> source;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> OptimizableOperator&lt;?, ? extends I&gt; nextOptimizableSource() &#123;</span><br><span class="line">		<span class="keyword">return</span> optimizableOperator;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说了那么多前置知识，在回到MonoMapFuseable本身。关键代码在subscribeOrReturn方法内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; subscribeOrReturn(CoreSubscriber&lt;? <span class="keyword">super</span> R&gt; actual) &#123;</span><br><span class="line">		<span class="keyword">if</span> (actual <span class="keyword">instanceof</span> ConditionalSubscriber) &#123;</span><br><span class="line">			ConditionalSubscriber&lt;? <span class="keyword">super</span> R&gt; cs = (ConditionalSubscriber&lt;? <span class="keyword">super</span> R&gt;) actual;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> FluxMapFuseable.MapFuseableConditionalSubscriber&lt;&gt;(cs, mapper);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> FluxMapFuseable.MapFuseableSubscriber&lt;&gt;(actual, mapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是MapFuseableSubscriber实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapFuseableSubscriber</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt;</span></span><br><span class="line"><span class="class">			<span class="keyword">implements</span> <span class="title">InnerOperator</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt;,</span></span><br><span class="line"><span class="class">			           <span class="title">QueueSubscription</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> CoreSubscriber&lt;? <span class="keyword">super</span> R&gt;        actual; <span class="comment">//下游Subscriber</span></span><br><span class="line">	<span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper; <span class="comment">//map变换</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean</span> done;  <span class="comment">//是否处理完</span></span><br><span class="line"></span><br><span class="line">	QueueSubscription&lt;T&gt; s;  <span class="comment">//上游subscription</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sourceMode; <span class="comment">//当前Subscriber的融合模式</span></span><br><span class="line"></span><br><span class="line">	MapFuseableSubscriber(CoreSubscriber&lt;? <span class="keyword">super</span> R&gt; actual,</span><br><span class="line">			Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper) &#123;</span><br><span class="line">		<span class="keyword">this</span>.actual = actual;</span><br><span class="line">		<span class="keyword">this</span>.mapper = mapper;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当订阅上游时，上游最终会触发下游的onSubscribe方法</span></span><br><span class="line">	<span class="comment">//第1步</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (Operators.validate(<span class="keyword">this</span>.s, s)) &#123;</span><br><span class="line">			<span class="comment">//直接转成QueueSubscription，有了前面Fuseable接口，这里转化是安全的</span></span><br><span class="line">			<span class="keyword">this</span>.s = (QueueSubscription&lt;T&gt;) s;  </span><br><span class="line"></span><br><span class="line">			<span class="comment">//把自身传给下游，因为也实现了QueueSubscription</span></span><br><span class="line">			actual.onSubscribe(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//然后下游会调用request或requestFusion，先看看这两个方法</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在第1步，即onSubscribe方法内，调用下游的onSubscribe方法。</span></span><br><span class="line">	<span class="comment">//如果下游支持处理融合的话，会调用到这里的requestFusion方法</span></span><br><span class="line">	<span class="comment">//第2步</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">requestFusion</span><span class="params">(<span class="keyword">int</span> requestedMode)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m;</span><br><span class="line">		<span class="comment">//下游请求跨线程融合，</span></span><br><span class="line">		<span class="comment">//因为这里全部实现都是未保证线程安全的，所以不支持跨线程融合</span></span><br><span class="line">		<span class="keyword">if</span> ((requestedMode &amp; Fuseable.THREAD_BARRIER) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> Fuseable.NONE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//融合往上游传递。例如MonoJust只支持同步融合，那么sourceMode == SYNC</span></span><br><span class="line">			m = s.requestFusion(requestedMode);</span><br><span class="line">		&#125;</span><br><span class="line">		sourceMode = m;</span><br><span class="line">		<span class="keyword">return</span> m; <span class="comment">//融合状态结果往下游传递</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//或者下游不支持融合的话，会调用到这里的request方法</span></span><br><span class="line">	<span class="comment">//或者下游异步融合模式，也会调用request方法</span></span><br><span class="line">	<span class="comment">//也算是第2步吧</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//请求拉取数据，直接往上游传，上游会发射数据到onNext方法</span></span><br><span class="line">		s.request(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//cancel方法跟request差不多处理方式，省略</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第3步：当向上游调用request方法时，上游会发射数据到onNext方法</span></span><br><span class="line">	<span class="comment">//不支持融合模式或者异步融合都会调用到onNext方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//说明下游请求异步融合了，那么通过onNext方法告知下游数据准备好了</span></span><br><span class="line">		<span class="keyword">if</span> (sourceMode == ASYNC) &#123;</span><br><span class="line">			actual.onNext(<span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="comment">//正常发射数据</span></span><br><span class="line">			<span class="keyword">if</span> (done) &#123; <span class="comment">//已完成，return</span></span><br><span class="line">				Operators.onNextDropped(t, actual.currentContext());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			R v;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//执行变换</span></span><br><span class="line">				<span class="comment">//可以看出整个流程中数据是不允许为null的</span></span><br><span class="line">				v = Objects.requireNonNull(mapper.apply(t),</span><br><span class="line">						<span class="string">&quot;The mapper returned a null value.&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">				<span class="comment">//hook方法执行</span></span><br><span class="line">				Throwable e_ = Operators.onNextError(t, e, actual.currentContext(), s);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//hook方法没能消化掉error</span></span><br><span class="line">				<span class="keyword">if</span> (e_ != <span class="keyword">null</span>) &#123;</span><br><span class="line">					onError(e_); <span class="comment">//执行下游actual#onError方法，通知处理失败</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//hook方法消化掉error，并再拉取一条数据</span></span><br><span class="line">					<span class="comment">//很明显，MonoJust会忽略掉，因为MonoJust只有一条数据</span></span><br><span class="line">					s.request(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//数据往下游流动</span></span><br><span class="line">			actual.onNext(v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当下游支持融合时，下游会调用poll方法主动拉取上游的数据</span></span><br><span class="line">	<span class="comment">//第4步：异步融合收到onNext方法的通知时，才会调用poll</span></span><br><span class="line">	<span class="comment">//同步融合时，再调用完requestFusion方法后得到上游支持同步融合时便可直接poll数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> R <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">		  T v = s.poll(); <span class="comment">//从上游拉取数据。</span></span><br><span class="line">		  <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">			  <span class="keyword">try</span> &#123;</span><br><span class="line">				  <span class="comment">//变换，返回。</span></span><br><span class="line">				  <span class="keyword">return</span> Objects.requireNonNull(mapper.apply(v));</span><br><span class="line">			  &#125;</span><br><span class="line">			  <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">				  RuntimeException e_ = Operators.onNextPollError(v, t, currentContext());</span><br><span class="line">				  <span class="keyword">if</span> (e_ != <span class="keyword">null</span>) &#123;</span><br><span class="line">					  <span class="keyword">throw</span> e_;</span><br><span class="line">				  &#125;</span><br><span class="line">				  <span class="keyword">else</span> &#123;</span><br><span class="line">					  <span class="keyword">continue</span>;</span><br><span class="line">				  &#125;</span><br><span class="line">			  &#125;</span><br><span class="line">		  &#125;</span><br><span class="line">		  <span class="comment">//如果是同步融合，返回null，代表数据已经发射完了，</span></span><br><span class="line">		  <span class="comment">//下游需要自己调用onComplete方法，而不是由上游触发</span></span><br><span class="line"></span><br><span class="line">		  <span class="comment">//如果是异步融合，代表本轮请求的数据已经处理完了</span></span><br><span class="line">		  <span class="comment">//继续等待onNext方法收到通知再poll数据，或者收到onComplete|onError 方法通知代表上游数据已经处理完了</span></span><br><span class="line">		  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (done) &#123; <span class="comment">//已经处理完成了，忽略掉</span></span><br><span class="line">			Operators.onErrorDropped(t, actual.currentContext());</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		done = <span class="keyword">true</span>; <span class="comment">//处理完的标志位设为true</span></span><br><span class="line">		<span class="comment">//异常往下游流动</span></span><br><span class="line">		actual.onError(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//onComplete方法跟onError类似，省略</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略若干代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h3><p><img src="/java-async-road-4/MonoFlatMap.png" alt="图片来源reactivex.io"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mono</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CorePublisher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Mono&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Mono&lt;? extends R&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">			transformer)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> onAssembly(<span class="keyword">new</span> MonoFlatMap&lt;&gt;(<span class="keyword">this</span>, transformer));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//很明显MonoFlatMap也是支持融合的</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MonoFlatMap</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">InternalMonoOperator</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">Fuseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> CoreSubscriber&lt;? <span class="keyword">super</span> T&gt; subscribeOrReturn(CoreSubscriber&lt;? <span class="keyword">super</span> R&gt; actual) &#123;</span><br><span class="line">		<span class="comment">//判断source是否继承Callable，前面分析提到过，callable是可以直接处理的</span></span><br><span class="line">		<span class="comment">//非主流程，属于优化细节，不深入分析</span></span><br><span class="line">		<span class="comment">//里面处理过对source的subscribe，所以这里return null,跳出while循环订阅</span></span><br><span class="line">		<span class="keyword">if</span> (FluxFlatMap.trySubscribeScalarMap(source, actual, mapper, <span class="keyword">true</span>, <span class="keyword">false</span>)) &#123; </span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		FlatMapMain&lt;T, R&gt; manager = <span class="keyword">new</span> FlatMapMain&lt;&gt;(actual, mapper);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//先把QueueSubscription往下游传，可以request请求到FlatMapMain</span></span><br><span class="line">		<span class="comment">//然后source#onSubscribe传下来Subscription，已经明确需要拉取的数据量大小了，也算是一个优化点</span></span><br><span class="line">		actual.onSubscribe(manager);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//返回Subscriber继续while循环订阅，直到数据源头</span></span><br><span class="line">		<span class="keyword">return</span> manager;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//FlatMapMain既是QueueSubscription，又是Subscriber</span></span><br><span class="line">	<span class="comment">//也就是需要处理下游请求的request，cancel方法，</span></span><br><span class="line">	<span class="comment">//也需要处理上游传下来的onSubscribe，onNext方法等</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FlatMapMain</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Operators</span>.<span class="title">MonoSubscriber</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T, ? extends Mono&lt;? extends R&gt;&gt; mapper;</span><br><span class="line">		<span class="keyword">final</span> FlatMapInner&lt;R&gt; second; <span class="comment">//新数据源的subscriber</span></span><br><span class="line">		<span class="keyword">boolean</span> done;</span><br><span class="line">		<span class="keyword">volatile</span> Subscription s;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//第1步：</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (Operators.setOnce(S, <span class="keyword">this</span>, s)) &#123;</span><br><span class="line">				<span class="comment">//很明显flatMap没有向上传请求融合</span></span><br><span class="line">				<span class="comment">//所以数据会从onNext方法从上游传下来</span></span><br><span class="line">				s.request(Long.MAX_VALUE);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//第2步：上游发射数据到onNext方法，</span></span><br><span class="line">		<span class="comment">//调用mapper方法产生新数据源并订阅</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (done) &#123;</span><br><span class="line">				Operators.onNextDropped(t, actual.currentContext());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//flatMap是换流，如果onNext处理完，那么上游就完了，</span></span><br><span class="line">			<span class="comment">//至于下游的onComplete方法会在flatMap产生新数据源中触发</span></span><br><span class="line">			done = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">			Mono&lt;? extends R&gt; m;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//flatMap变换</span></span><br><span class="line">				m = Objects.requireNonNull(mapper.apply(t),</span><br><span class="line">						<span class="string">&quot;The mapper returned a null Mono&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				actual.onError(Operators.onOperatorError(s, ex, t,</span><br><span class="line">						actual.currentContext()));</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//对单值已完成数据源的一种优化，前面分析过了</span></span><br><span class="line">			<span class="keyword">if</span> (m <span class="keyword">instanceof</span> Callable) &#123;</span><br><span class="line">				<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> Callable&lt;R&gt; c = (Callable&lt;R&gt;) m;</span><br><span class="line"></span><br><span class="line">				R v;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					v = c.call();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					actual.onError(Operators.onOperatorError(s, ex, t,</span><br><span class="line">							actual.currentContext()));</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">					actual.onComplete();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					complete(v);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//订阅新数据源</span></span><br><span class="line">				m.subscribe(second);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">				actual.onError(Operators.onOperatorError(<span class="keyword">this</span>, e, t,</span><br><span class="line">						actual.currentContext()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//--------------------------</span></span><br><span class="line">		<span class="comment">//下游在onSubscribe方法收到上游的QueueSubscription时，可能执行融合操作</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//第3步：下游请求融合，返回支持异步融合</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">requestFusion</span><span class="params">(<span class="keyword">int</span> mode)</span> </span>&#123;</span><br><span class="line">			<span class="comment">//因为新数据源何时能发射是未知的，所以是异步融合</span></span><br><span class="line">			<span class="keyword">if</span> ((mode &amp; ASYNC) != <span class="number">0</span>) &#123;</span><br><span class="line">				STATE.lazySet(<span class="keyword">this</span>, FUSED_EMPTY); <span class="comment">//设置融合标志位</span></span><br><span class="line">				<span class="keyword">return</span> ASYNC;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//only async</span></span><br><span class="line">			<span class="keyword">return</span> NONE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//第4步：不管是异步融合还是不支持融合时，都需要调用request方法</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">		    <span class="keyword">if</span> (validate(n)) &#123;</span><br><span class="line">			    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">			       <span class="keyword">int</span> s = state;</span><br><span class="line">  			    </span><br><span class="line">			        <span class="comment">//标记位已经被处理过，直接return</span></span><br><span class="line">			        <span class="comment">//处理过定义：已经请求该request方法，融合过，cancel过，</span></span><br><span class="line">			        <span class="keyword">if</span> ((s &amp; ~NO_REQUEST_HAS_VALUE) != <span class="number">0</span>) &#123;</span><br><span class="line">				        <span class="keyword">return</span>;</span><br><span class="line">			        &#125;</span><br><span class="line">  			    </span><br><span class="line">			        <span class="comment">//上游已经发射值了，但未request</span></span><br><span class="line">			        <span class="comment">//所以直接往下游发射数据即可</span></span><br><span class="line">			        <span class="keyword">if</span> (s == NO_REQUEST_HAS_VALUE &amp;&amp; STATE.compareAndSet(<span class="keyword">this</span>, NO_REQUEST_HAS_VALUE, HAS_REQUEST_HAS_VALUE)) &#123;</span><br><span class="line">				        O v = value;</span><br><span class="line">				        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">					        value = <span class="keyword">null</span>;</span><br><span class="line">					        Subscriber&lt;? <span class="keyword">super</span> O&gt; a = actual;</span><br><span class="line">					        a.onNext(v);</span><br><span class="line">					        a.onComplete();</span><br><span class="line">				        &#125;</span><br><span class="line">				        <span class="keyword">return</span>;</span><br><span class="line">			        &#125;</span><br><span class="line">  			    </span><br><span class="line">			        <span class="comment">//设置请求过的标志位</span></span><br><span class="line">			        <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NO_REQUEST_NO_VALUE, HAS_REQUEST_NO_VALUE)) &#123;</span><br><span class="line">				      <span class="keyword">return</span>;</span><br><span class="line">				    &#125;</span><br><span class="line">			    &#125;<span class="comment">//for end</span></span><br><span class="line">  		    &#125; <span class="comment">//if end</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//第5步：新数据源发射数据时，最终会调用该方法</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(O v)</span> </span>&#123;</span><br><span class="line">		    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">			  <span class="keyword">int</span> state = <span class="keyword">this</span>.state;</span><br><span class="line">			  <span class="keyword">if</span> (state == FUSED_EMPTY) &#123;  <span class="comment">//下游调用了requestFusion方法，进行异步融合</span></span><br><span class="line">				  setValue(v);</span><br><span class="line">				  </span><br><span class="line">				  <span class="comment">//只标志位为融合准备完成,调用下游的onNext方法通知，</span></span><br><span class="line">				  <span class="comment">//并调用onComplete方法通知下游数据已发射完</span></span><br><span class="line">				  <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, FUSED_EMPTY, FUSED_READY)) &#123;</span><br><span class="line">					  Subscriber&lt;? <span class="keyword">super</span> O&gt; a = actual;</span><br><span class="line">					  a.onNext(v);</span><br><span class="line">					  a.onComplete();</span><br><span class="line">					  <span class="keyword">return</span>;</span><br><span class="line">				  &#125;</span><br><span class="line">				  <span class="comment">//refresh state if race occurred so we test if cancelled in the next comparison</span></span><br><span class="line">				  state = <span class="keyword">this</span>.state;</span><br><span class="line">			  &#125;</span><br><span class="line">			  </span><br><span class="line">			  <span class="comment">//下面是对未进行融合的处理    </span></span><br><span class="line">			  <span class="comment">//已经设置过了，执行丢弃value hook，并return</span></span><br><span class="line">			  <span class="keyword">if</span> ((state &amp; ~HAS_REQUEST_NO_VALUE) != <span class="number">0</span>) &#123;</span><br><span class="line">				  discard(v);</span><br><span class="line">				  <span class="keyword">return</span>;</span><br><span class="line">			  &#125;</span><br><span class="line">			  </span><br><span class="line">			  <span class="comment">//下游已执行过request，那么直接往下游继续发射数据</span></span><br><span class="line">			  <span class="keyword">if</span> (state == HAS_REQUEST_NO_VALUE &amp;&amp; STATE.compareAndSet(<span class="keyword">this</span>, HAS_REQUEST_NO_VALUE, HAS_REQUEST_HAS_VALUE)) &#123;</span><br><span class="line">				  <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">				  Subscriber&lt;? <span class="keyword">super</span> O&gt; a = actual;</span><br><span class="line">				  a.onNext(v);</span><br><span class="line">				  a.onComplete();</span><br><span class="line">				  <span class="keyword">return</span>;</span><br><span class="line">			  &#125;</span><br><span class="line">			  </span><br><span class="line">			  <span class="comment">//未执行过request，保存value并设置有值标志位</span></span><br><span class="line">			  setValue(v);</span><br><span class="line">			  <span class="keyword">if</span> (state == NO_REQUEST_NO_VALUE &amp;&amp; STATE.compareAndSet(<span class="keyword">this</span>, NO_REQUEST_NO_VALUE, NO_REQUEST_HAS_VALUE)) &#123;</span><br><span class="line">				  <span class="keyword">return</span>;</span><br><span class="line">			  &#125;</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//第6步：下游请求异步融合时，收到上面complete方法（第一个if分支）中发射发出的通知。</span></span><br><span class="line">		<span class="comment">//注意此时下游的onNext不再是数据了，而是通知。下游调用上游的QueueSubscription#poll方法拉取数据</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> O <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, FUSED_READY, FUSED_CONSUMED)) &#123; <span class="comment">//异步融合消费完成</span></span><br><span class="line">				O v = value;</span><br><span class="line">				value = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">return</span> v;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//省略若干代码</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//还有一个分支，对新数据源的订阅处理</span></span><br><span class="line">	<span class="comment">//即上面onNext方法内 m.subscribe(second)，这个second</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FlatMapInner</span>&lt;<span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">InnerConsumer</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> FlatMapMain&lt;?, R&gt; parent;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">volatile</span> Subscription s;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//这个subscriber也不会做请求融合处理</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription s)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (Operators.setOnce(S, <span class="keyword">this</span>, s)) &#123;</span><br><span class="line">				<span class="comment">//直接拉满</span></span><br><span class="line">				s.request(Long.MAX_VALUE);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//最终还是调到上面分析的FlatMapMain#complete方法</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(R t)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (done) &#123;</span><br><span class="line">				Operators.onNextDropped(t, parent.currentContext());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			done = <span class="keyword">true</span>;</span><br><span class="line">			<span class="comment">//接连上面的第5步</span></span><br><span class="line">			<span class="keyword">this</span>.parent.complete(t);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//省略若干代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flatMap操作符已经分析完了。<br>到此，或者我翻遍Mono绝大部分操作符，都没有找到请求融合的操作。即下游调用上游传下来的QueueSubscription#requestFusion方法。为什么？</p>
<blockquote>
<p>因为不需要，Mono至多就发射一个数据，融合和不融合没什么区别，甚至我一度很怀疑Mono为什么会有融合的代码。<br>我一个原因可能就是toFlux操作符，转成Flux之后，融合就变得有意义了。</p>
</blockquote>
<hr>
<p>分析Mono#flatMap操作符时，我发现一个bug。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Mono.just(<span class="string">&quot;name&quot;</span>)                       <span class="comment">//创建发射单个数据的数据源Mono</span></span><br><span class="line">            .map(str -&gt; str + <span class="string">&quot;: wang007&quot;</span>)      <span class="comment">//对数据进行转换</span></span><br><span class="line">            .flatMap(str -&gt; &#123;                   <span class="comment">//平铺</span></span><br><span class="line">                System.out.println(<span class="string">&quot;str -&gt; &quot;</span> + str);</span><br><span class="line">                <span class="keyword">return</span> Mono.defer(() -&gt; Mono.just(str.length()));</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">//.map(len -&gt; len + &quot;&quot; + len)                //再转换，转换成String的长度</span></span><br><span class="line">            <span class="comment">//.filter(lenStr -&gt; lenStr.length() &gt; 5)     //过滤</span></span><br><span class="line">            .subscribe(str -&gt; &#123;                        <span class="comment">//订阅</span></span><br><span class="line">                System.out.println(<span class="string">&quot;result -&gt; &quot;</span> + str);</span><br><span class="line">            &#125;, err -&gt; &#123;              err.printStackTrace();</span><br><span class="line">            &#125;, () -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;onComplete&quot;</span>);</span><br><span class="line">            &#125;, subscription -&gt; &#123;</span><br><span class="line">                <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5_000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Fuseable.QueueSubscription s = (Fuseable.QueueSubscription) subscription;</span><br><span class="line">                    s.requestFusion(Fuseable.ASYNC);</span><br><span class="line">                    subscription.request(Long.MAX_VALUE);</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<p>触发条件：</p>
<ol>
<li>flatMap的新数据源头先发射处理到FlatMapMain，然后标志位置为NO_REQUEST_HAS_VALUE。</li>
<li>下游请求异步融合，在FlatMapMain#requestFusion方法内，标志位直接FUSED_EMPTY。</li>
<li>下游调用request方法要求发射数据，结果在FlatMapMain#request方法内会被忽略掉。</li>
<li>bug结果是下游的onNext方法，onComplete或onError方法不会再触发了</li>
</ol>
<hr>
<p>讲了两个操作符篇幅就过长了，所以得另看一篇文章继续写了。<br>本文分析基于3.3.0.RELEASE版本</p>
<p>参考文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://reactivex.io/">reactiveX官网</a> </li>
<li><a target="_blank" rel="noopener" href="http://projectreactor.io/">project Reactor官网</a> </li>
</ul>
<hr>
<p>好了，时间不早了，晚安。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag"># 异步</a>
              <a href="/tags/reactive/" rel="tag"># reactive</a>
              <a href="/tags/Project-Reactor/" rel="tag"># Project Reactor</a>
              <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag"># 响应式编程</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/java-async-road-5/" rel="prev" title="java异步编程探究-Project Reactor实现原理-2">
                  <i class="fa fa-chevron-left"></i> java异步编程探究-Project Reactor实现原理-2
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/java-async-road-3/" rel="next" title="java异步编程探究-响应式编程">
                  java异步编程探究-响应式编程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wang007</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

</body>
</html>
