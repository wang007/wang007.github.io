<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="该文章是 Java 异步编程探究系列文章的第二章。如果还没看第一篇文章的话，可以先看下第二篇文章。 上篇文章提到了，异步往往伴随着 callback，而且 callback 多了之后，很容易形成 callback hell 导致代码被割据到各个 callback 中。以至于代码难以阅读和维护。 这篇文章谈谈解决callback hell的方式之一，Future。">
<meta property="og:type" content="article">
<meta property="og:title" content="java 异步编程探究-Future">
<meta property="og:url" content="http://example.com/java-async-road-2/index.html">
<meta property="og:site_name" content="wang007 blog">
<meta property="og:description" content="该文章是 Java 异步编程探究系列文章的第二章。如果还没看第一篇文章的话，可以先看下第二篇文章。 上篇文章提到了，异步往往伴随着 callback，而且 callback 多了之后，很容易形成 callback hell 导致代码被割据到各个 callback 中。以至于代码难以阅读和维护。 这篇文章谈谈解决callback hell的方式之一，Future。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-11-28T07:07:18.000Z">
<meta property="article:modified_time" content="2021-01-28T07:17:33.508Z">
<meta property="article:author" content="wang007">
<meta property="article:tag" content="java">
<meta property="article:tag" content="异步">
<meta property="article:tag" content="CompletionStage">
<meta property="article:tag" content="CompletableFuture">
<meta property="article:tag" content="ListenableFuture">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/java-async-road-2/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java 异步编程探究-Future | wang007 blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">wang007 blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%B8%A1%E8%82%8B%E7%9A%84-Future"><span class="nav-number">1.</span> <span class="nav-text">鸡肋的 Future</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Future-api"><span class="nav-number">1.1.</span> <span class="nav-text">Future api</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95-Future"><span class="nav-number">2.</span> <span class="nav-text">拓展 Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%81%E5%85%B6%E4%B8%91%E9%99%8B%E7%9A%84-CompletableFuture"><span class="nav-number">3.</span> <span class="nav-text">极其丑陋的 CompletableFuture</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletionStage"><span class="nav-number">3.1.</span> <span class="nav-text">CompletionStage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9C%A8%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C%E6%AD%A3%E5%B8%B8%E5%AE%8C%E6%88%90%E6%97%B6%E8%B0%83%E7%94%A8%E3%80%82%E5%8C%BA%E5%88%AB%E5%9C%A8%E4%BA%8E%E5%85%A5%E5%8F%82%E5%92%8C%E5%87%BA%E5%8F%82%E3%80%82-fuck-api-%E7%9B%B8%E5%BD%93%E4%BA%8Ereactive-map"><span class="nav-number">3.2.</span> <span class="nav-text">1. 在异步结果正常完成时调用。区别在于入参和出参。 fuck api  相当于reactive#map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%BD%93%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C%E9%83%BD%E6%AD%A3%E5%B8%B8%E5%AE%8C%E6%88%90%E6%97%B6%E8%B0%83%E7%94%A8%EF%BC%8C%E5%8C%BA%E5%88%AB%E5%9C%A8%E4%BA%8E%E5%85%A5%E5%8F%82%E5%92%8C%E5%87%BA%E5%8F%82%E3%80%82fuck-api-%E7%9B%B8%E5%BD%93%E4%BA%8Ereactive-zipWith"><span class="nav-number">3.3.</span> <span class="nav-text">2. 当两个异步结果都正常完成时调用，区别在于入参和出参。fuck api  相当于reactive#zipWith</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C%E4%BB%BB%E6%84%8F%E5%85%B6%E4%B8%AD%E4%B9%8B%E4%B8%80%E6%AD%A3%E5%B8%B8%E5%AE%8C%E6%88%90%E6%97%B6%E8%B0%83%E7%94%A8%EF%BC%8C%E5%8C%BA%E5%88%AB%E5%9C%A8%E4%BA%8E%E5%85%A5%E5%8F%82%E5%92%8C%E5%87%BA%E5%8F%82%E3%80%82-fuck-api-%E7%9B%B8%E5%BD%93%E4%BA%8Ereactive-ambWith-amp-amp-map"><span class="nav-number">3.4.</span> <span class="nav-text">3. 两个异步结果任意其中之一正常完成时调用，区别在于入参和出参。 fuck api  相当于reactive#ambWith &amp;&amp; map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%BD%93%E5%89%8D%E4%B8%80%E4%B8%AA%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C%E6%AD%A3%E5%B8%B8%E5%AE%8C%E6%88%90%E6%97%B6%E4%BA%A7%E7%94%9F%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C%E3%80%82-%E6%8C%BA%E5%A5%BD%E3%80%82-%E7%9B%B8%E5%BD%93%E4%BA%8Ereactive-flatMap"><span class="nav-number">3.5.</span> <span class="nav-text">4. 当前一个异步结果正常完成时产生一个新的不同类型的异步结果。  挺好。 相当于reactive#flatMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%BD%93%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C%E5%BC%82%E5%B8%B8%E5%AE%8C%E6%88%90%E6%97%B6%E8%B0%83%E7%94%A8-%E7%9B%B8%E5%BD%93%E4%BA%8Ereactive-onErrorReturn"><span class="nav-number">3.6.</span> <span class="nav-text">5. 当异步结果异常完成时调用  相当于reactive#onErrorReturn</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%BD%93%E5%BC%82%E6%AD%A5%E7%BB%93%E6%9E%9C%E5%AE%8C%E6%88%90-%E5%8C%85%E6%8B%AC%E6%AD%A3%E5%B8%B8%E6%88%96%E5%BC%82%E5%B8%B8-%E6%97%B6%E8%B0%83%E7%94%A8%E3%80%82-%E7%9B%B8%E5%BD%93%E4%BA%8Ereactive-doOnSubscribe"><span class="nav-number">3.7.</span> <span class="nav-text">6. 当异步结果完成(包括正常或异常)时调用。 相当于reactive#doOnSubscribe</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletionStage-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.8.</span> <span class="nav-text">CompletionStage 的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%80%E4%BB%A5%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A1%86%E6%9E%B6%EF%BC%8C%E9%83%BD%E6%98%AF%E5%9F%BA%E4%BA%8E%E8%BF%99%E7%A7%8D%E5%9B%9E%E8%B0%83%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87%E5%90%84%E7%A7%8D%E6%89%8B%E6%AE%B5%E4%B8%8D%E6%96%AD%E5%9C%B0%E5%8E%BB%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%B5%8C%E5%A5%97%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82%E4%B8%8B%E9%9D%A2%E5%8D%B3%E5%B0%86%E8%AE%B2%E5%88%B0%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B%EF%BC%8C%E4%B9%9F%E6%98%AF%E5%A6%82%E6%AD%A4%E3%80%82"><span class="nav-number">3.9.</span> <span class="nav-text">所以异步非阻塞框架，都是基于这种回调的方式，然后通过各种手段不断地去解决回调嵌套的问题。下面即将讲到的响应式编程，协程，也是如此。</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wang007</p>
  <div class="site-description" itemprop="description">wang007 blog</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/java-async-road-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wang007">
      <meta itemprop="description" content="wang007 blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wang007 blog">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java 异步编程探究-Future
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-28 15:07:18" itemprop="dateCreated datePublished" datetime="2019-11-28T15:07:18+08:00">2019-11-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-28 15:17:33" itemprop="dateModified" datetime="2021-01-28T15:17:33+08:00">2021-01-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/%E5%BC%82%E6%AD%A5/" itemprop="url" rel="index"><span itemprop="name">异步</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>该文章是 Java 异步编程探究系列文章的第二章。<br>如果还没看第一篇文章的话，可以先看下第二篇文章。</p>
<p>上篇文章提到了，异步往往伴随着 callback，而且 callback 多了之后，很容易形成 callback hell 导致代码被割据到各个 callback 中。以至于代码难以阅读和维护。</p>
<p>这篇文章谈谈解决callback hell的方式之一，Future。</p>
<a id="more"></a>

<blockquote>
<p>自 Java1.8 起，终于在jdk中对异步回调有了类库的支持。添加了 CompletableFuture。虽然这货添加了，但是可恶的 CompletableFuture api 极其丑陋。下面细说这个 CompletableFuture。</p>
</blockquote>
<h3 id="鸡肋的-Future"><a href="#鸡肋的-Future" class="headerlink" title="鸡肋的 Future"></a>鸡肋的 Future</h3><blockquote>
<p>jd k自带的 Future 没有提供对 callback 的解决方案，这里讨论Future是为了更好的引出CompletableFuture。</p>
</blockquote>
<p>对于 Future 用法，一般是使用 Executor#submit 方法，提交一个作业任务并返回一个 Future。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;String&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;executor&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        future.get(); <span class="comment">//阻塞到作业任务执行完。</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，向线程池提交一个作业任务并返回一个 Future。<br>但是这个 Future 没有提供回调的方式，需要你手动调用get方法去获取结果。但是一旦这个 Runnable 还未执行完的话，那么调用 get 方法的线程就会被阻塞掉。非常的不方便。<br>所以这个 Future 非常不适合线程间的作业交互。也就是说即便有了这个 Future，你想要获取结果也很麻烦，因为没结果就阻塞当前线程不是一个好的方法。</p>
<p>下面来分析一下Future的源码，以及它为什么会阻塞。</p>
<h4 id="Future-api"><a href="#Future-api" class="headerlink" title="Future api"></a>Future api</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//取消当前future代表的任务。</span></span><br><span class="line">  <span class="comment">//mayInterruptIfRunning 参数: 是否需要中断线程</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果任务未执行完，那么将阻塞完到任务执行完。</span></span><br><span class="line">  <span class="comment">//任务执行过程中发生异常的话，异常将会包装到ExecutionException中并抛出。</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//带超时的get方法</span></span><br><span class="line">  <span class="comment">//note；如果timeout时间内未执行完，那么将抛出TimeoutException，而非返回null。因为null也是result的一种。</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看看 Future 的标准实现：FutureTask<br>FutureTask 实现了 Runnable 接口，所以 FutureTask 可以当做一个普通的 Runnable 提交到线程池中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码在AbstractExecutorService类中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask); <span class="comment">//最终也是通过execute方法往线程池提交任务。</span></span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state; <span class="comment">//状态，代表任务执行到哪个阶段， 同时也作为竞态条件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;   <span class="comment">//新建阶段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;   <span class="comment">//callable已执行完，下一步马上设置结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;   <span class="comment">//任务执行完，并设置设置正常的result</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;   <span class="comment">//任务执行过程中发生异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;   <span class="comment">//任务被取消</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;   <span class="comment">//任务带中断取消的中间状态，也就是执行cannel(true)方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;   <span class="comment">//任务带中断取消的最终状态。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户提交的作业任务，提交的作业任务是Runnable的话，最终也是包装成Callable的。</span></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结果，包装正常的result，或非正常的异常结果。异常结果往往throw</span></span><br><span class="line">    <span class="comment">//注意下面的注释，很有意思。很值得研究的一个知识点。这里不展开分析了。</span></span><br><span class="line">    <span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行任务的底层线程，这个对象还充当是否已执行任务的竞态条件。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用get方法，get(timeout)方法而阻塞的线程等待节点。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里state和runner两个竟态条件都必须满足</span></span><br><span class="line">        <span class="comment">//如果state不满足，这个future可能被取消或被执行完了</span></span><br><span class="line">        <span class="comment">//如果runner不满足，说明此刻其他线程正在运行着</span></span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123; <span class="comment">//还没有线程执行过，且没有cancel。</span></span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();  <span class="comment">//执行作业任务</span></span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    setException(ex); <span class="comment">//这个ex可能是callable任务中抛出来的，当然也就包括了InterruptedException</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result); <span class="comment">//设置结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">		<span class="comment">//这种情况是try里面的if条件没满足。即被cancel了。避免run方法结束时，存在state == INTERRUPTING 这个中间状态</span></span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置异常结果</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果执行过程中，有调用cannel方法的话，那么此刻state状态有可能是CANCELLED,INTERRUPTING,INTERRUPTED中的任意一种。</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123; <span class="comment">//如果没修改，那么就设置异常到outcome属性中，最后通过修改state变量发布出去。</span></span><br><span class="line">            outcome = t;</span><br><span class="line">            UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置正常结果的方法跟上面异常结果的相似，所以不讲了</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置完结果后，就开始唤醒阻塞在该future的线程。</span></span><br><span class="line">    <span class="comment">//该方法调用一次有且只有一次。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">          <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;  <span class="comment">//CAS设置watiers，true的话，则竞争成功，逐个唤醒线程。这里有且只有一次能操作成功</span></span><br><span class="line">              <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                  Thread t = q.thread;</span><br><span class="line">                  <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      q.thread = <span class="keyword">null</span>;</span><br><span class="line">                      LockSupport.unpark(t); <span class="comment">//唤醒线程</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  WaitNode next = q.next;</span><br><span class="line">                  <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                  q = next;</span><br><span class="line">              &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      done();   <span class="comment">//这个留给后续拓展的。</span></span><br><span class="line"></span><br><span class="line">      callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//最后来看看get方法， get(timeout)方法类似，分析一个即可</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">//&lt;=COMPLETING是未完成状态，所以讲当前线程加入等待队列中</span></span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING) s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s); <span class="comment">//根据状态输出结果</span></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;   <span class="comment">//被中断，直接throw，通知调用方。</span></span><br><span class="line">                removeWaiter(q);  <span class="comment">//清除当前节点，这里是单向链接的删除操作。</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;  <span class="comment">//已完成之后，退出。 加入等待队列后退出当前方法出口也是这里</span></span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">//即将完成，所以使用yield让出时间片的方式</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode(); <span class="comment">//创建等待节点，再下一次循环的时候使用</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);   <span class="comment">//竞争waiters条件，成功的话，则入队成功，可以park了（阻塞挂起）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;  <span class="comment">//定时park处理</span></span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述，就把 FutureTask 的关键方法梳理了一遍。<br>根据源码有关 state 的转向，在注释上也写的很明白。</p>
<ol>
<li>NEW（新建） -&gt; COMPLETING（处理中）-&gt; NORMAL（正常完成）</li>
<li>NEW（新建） -&gt; COMPLETING（处理中）-&gt; EXCEPTIONAL（异常完成）</li>
<li>NEW（新建） -&gt; CANCELLED（取消）</li>
<li>NEW（新建） -&gt; INTERRUPTING（带中断的取消中）-&gt; INTERRUPTED（带中断的取消完成）</li>
</ol>
<p>所以 isCannel 方法判断是否是取消的，就判断 state &gt;= CANCELLED</p>
<h3 id="拓展-Future"><a href="#拓展-Future" class="headerlink" title="拓展 Future"></a>拓展 Future</h3><p>既然 Future#get 方法只能阻塞获取节点，而且上面分析了 FutureTask 也已经留了口子，那么就实现一个基于回调可监听的 Future。<br>具体源码在<a target="_blank" rel="noopener" href="https://github.com/wang007/pandora/tree/master/pandora-ext/src/main/java/com/github/pandora/listenable">ListenableFuture</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现后的效果</span></span><br><span class="line">ListenableExecutorService executor = ListenableExecutor.create(Executors.newSingleThreadExecutor());</span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;submit&quot;</span>;</span><br><span class="line">&#125;).addHandler(ar -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;submit result -&gt; &quot;</span> + ar.result());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ar.cause().printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者用链式串联异步结果</span></span><br><span class="line">executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;submit&quot;</span>;</span><br><span class="line">&#125;).flatMap(str -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;other&quot;</span>;</span><br><span class="line">&#125;).map(str -&gt; &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="keyword">return</span> str.length();</span><br><span class="line">&#125;).addHandler(ar -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;result length -&gt; &quot;</span> + ar.result());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ar.cause().printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="极其丑陋的-CompletableFuture"><a href="#极其丑陋的-CompletableFuture" class="headerlink" title="极其丑陋的 CompletableFuture"></a>极其丑陋的 CompletableFuture</h3><blockquote>
<p>CompletableFuture 继承了 CompletionStage, java中的阻塞 Future，所以 CompletableFuture 本身还是可以阻塞的。</p>
</blockquote>
<h4 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage</h4><p>CompletionStage 所有的方法，定义如何获取结果并做响应的操作。但是没有定义如何为这个异步结果设置结果，而设置这个操作直接就实现在具体的实现类 CompletableFuture 中，这就显得非常糟糕了，使用者必须去依赖 CompletableFuture 这个具体的实现了。<br>理想情况下，应该设置一个专门设置异步结果的接口。假设叫做 Promise。 Promise 只需要关注如何写，CompletionStage 只需要关注如何获取结果。<br>而 Netty 就是这么做的。参考 Netty 的 Promise，Future。</p>
<p>CompletionStage api 的设计同样非常糟糕，重复功能相同的 api。以至于后面我用同一个实现方法，其他接口方法都可以直接复用这个实现方法。<br>而且接口方法很难理解，远没有 reactive 的命名简洁。</p>
<p>下面就先给 api 做一个分类。后面使用的时候可以参考这个分类使用。</p>
<h4 id="1-在异步结果正常完成时调用。区别在于入参和出参。-fuck-api-相当于reactive-map"><a href="#1-在异步结果正常完成时调用。区别在于入参和出参。-fuck-api-相当于reactive-map" class="headerlink" title="1. 在异步结果正常完成时调用。区别在于入参和出参。 fuck api  相当于reactive#map"></a>1. 在异步结果正常完成时调用。区别在于入参和出参。 fuck api  相当于reactive#map</h4><pre><code> 1. &#123;@link #thenApply(Function),#thenApplyAsync(Function),#thenApplyAsync(Function, Executor)&#125;
 2. &#123;@link #thenAccept(Consumer),#thenAcceptAsync(Consumer),#thenAcceptAsync(Consumer, Executor)&#125;
 3. &#123;@link #thenRun(Runnable),#thenRunAsync(Runnable),#thenAcceptAsync(Consumer, Executor)&#125;</code></pre>
<h4 id="2-当两个异步结果都正常完成时调用，区别在于入参和出参。fuck-api-相当于reactive-zipWith"><a href="#2-当两个异步结果都正常完成时调用，区别在于入参和出参。fuck-api-相当于reactive-zipWith" class="headerlink" title="2. 当两个异步结果都正常完成时调用，区别在于入参和出参。fuck api  相当于reactive#zipWith"></a>2. 当两个异步结果都正常完成时调用，区别在于入参和出参。fuck api  相当于reactive#zipWith</h4><pre><code> 1. &#123;@link #thenCombine(CompletionStage, BiFunction),#thenCombineAsync(CompletionStage, BiFunction)&#125;
    &#123;@link #thenCombineAsync(CompletionStage, BiFunction, Executor)&#125;
 2. &#123;@link #thenAcceptBoth(CompletionStage, BiConsumer),#thenAcceptBothAsync(CompletionStage, BiConsumer),
    &#123;@link #thenAcceptBothAsync(CompletionStage, BiConsumer, Executor)&#125;
 3. &#123;@link #runAfterBoth(CompletionStage, Runnable),#runAfterBothAsync(CompletionStage, Runnable)&#125;
    &#123;@link #runAfterBothAsync(CompletionStage, Runnable, Executor)&#125;</code></pre>
<h4 id="3-两个异步结果任意其中之一正常完成时调用，区别在于入参和出参。-fuck-api-相当于reactive-ambWith-amp-amp-map"><a href="#3-两个异步结果任意其中之一正常完成时调用，区别在于入参和出参。-fuck-api-相当于reactive-ambWith-amp-amp-map" class="headerlink" title="3. 两个异步结果任意其中之一正常完成时调用，区别在于入参和出参。 fuck api  相当于reactive#ambWith &amp;&amp; map"></a>3. 两个异步结果任意其中之一正常完成时调用，区别在于入参和出参。 fuck api  相当于reactive#ambWith &amp;&amp; map</h4><pre><code> 1. &#123;@link #applyToEither(CompletionStage, Function),#applyToEitherAsync(CompletionStage, Function)&#125;
    &#123;@link #applyToEitherAsync(CompletionStage, Function, Executor)&#125;
 2. &#123;@link #acceptEither(CompletionStage, Consumer),#acceptEitherAsync(CompletionStage, Consumer)&#125;
    &#123;@link #acceptEitherAsync(CompletionStage, Consumer, Executor)&#125;
 3. &#123;@link #runAfterEither(CompletionStage, Runnable),#runAfterEitherAsync(CompletionStage, Runnable)&#125;
    &#123;@link #runAfterEitherAsync(CompletionStage, Runnable, Executor)&#125;</code></pre>
<h4 id="4-当前一个异步结果正常完成时产生一个新的不同类型的异步结果。-挺好。-相当于reactive-flatMap"><a href="#4-当前一个异步结果正常完成时产生一个新的不同类型的异步结果。-挺好。-相当于reactive-flatMap" class="headerlink" title="4. 当前一个异步结果正常完成时产生一个新的不同类型的异步结果。  挺好。 相当于reactive#flatMap"></a>4. 当前一个异步结果正常完成时产生一个新的不同类型的异步结果。  挺好。 相当于reactive#flatMap</h4><pre><code>1. &#123;@link #thenCompose(Function),#thenComposeAsync(Function, Executor),#thenComposeAsync(Function)&#125;</code></pre>
<h4 id="5-当异步结果异常完成时调用-相当于reactive-onErrorReturn"><a href="#5-当异步结果异常完成时调用-相当于reactive-onErrorReturn" class="headerlink" title="5. 当异步结果异常完成时调用  相当于reactive#onErrorReturn"></a>5. 当异步结果异常完成时调用  相当于reactive#onErrorReturn</h4><pre><code>1. &#123;@link #exceptionally(Function)&#125;</code></pre>
<h4 id="6-当异步结果完成-包括正常或异常-时调用。-相当于reactive-doOnSubscribe"><a href="#6-当异步结果完成-包括正常或异常-时调用。-相当于reactive-doOnSubscribe" class="headerlink" title="6. 当异步结果完成(包括正常或异常)时调用。 相当于reactive#doOnSubscribe"></a>6. 当异步结果完成(包括正常或异常)时调用。 相当于reactive#doOnSubscribe</h4><pre><code>1. &#123;@link #whenComplete(BiConsumer),#whenCompleteAsync(BiConsumer),#whenCompleteAsync(BiConsumer, Executor)&#125;
2. &#123;@link #handle(BiFunction),#handleAsync(BiFunction),#handleAsync(BiFunction, Executor)&#125;</code></pre>
<p>所以一共就 6 种功能的方法，用 reactiveX 命名操作符概括的话就是 map, zipWith, ambWith(or) &amp;&amp; map, flatMap, onErrorReturn, doOnSubscribe.<br>async 结尾的方法，是带切换线程的方法。</p>
<h4 id="CompletionStage-的实现"><a href="#CompletionStage-的实现" class="headerlink" title="CompletionStage 的实现"></a>CompletionStage 的实现</h4><blockquote>
<p>CompletableFuture 也并没有实现一个功能相同的方法，其他功能相同的方法复用。只是区别有没有线程池(async结尾的方法)做一个复用。<br>  由于源码实现比较多，所以我相同功能的方法拿出一个来分析即可，其他基本都一样。<br>  也就是说：thenApply 和 thenApplyAsync 做一个实现。thenAccept 和 thenAcceptAsync 又做一个实现分类，等等。</p>
</blockquote>
<ol>
<li>map 操作符 == thenApply 方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt;, <span class="title">CompletionStage</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用于包装异常结果，取结果时，result instanceOf AltResult 即可判断是否是异常结果</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AltResult</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Throwable ex; </span><br><span class="line">            AltResult(Throwable ex) &#123; <span class="keyword">this</span>.ex = ex; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> AltResult NIL = <span class="keyword">new</span> AltResult(<span class="keyword">null</span>);  <span class="comment">//当ex == null, 代表成功的null结果。</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">volatile</span> Object result;    <span class="comment">// </span></span><br><span class="line">        <span class="keyword">volatile</span> WaitNode waiters; <span class="comment">// get，get(timeOut)方法调用阻塞的线程节点</span></span><br><span class="line">        <span class="keyword">volatile</span> CompletionNode completions;  <span class="comment">//操作符对应的操作符节点。结果未完成时需要保存下来，待结果完成时在回调操作符。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//操作符节点是用单向链表保存起来的</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletionNode</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Completion completion;</span><br><span class="line">            <span class="keyword">volatile</span> CompletionNode next;</span><br><span class="line">            CompletionNode(Completion completion) &#123; <span class="keyword">this</span>.completion = completion; &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; thenApply</span><br><span class="line">               (Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn) &#123;</span><br><span class="line">               <span class="keyword">return</span> doThenApply(fn, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//最后调用到doThenApply方法</span></span><br><span class="line">       <span class="comment">//fn：操作符对应的操作，一般以lambda的形式提供，</span></span><br><span class="line">       <span class="comment">//e：是否需要切换线程，async结尾的方法 e != null</span></span><br><span class="line">       <span class="keyword">private</span> &lt;U&gt; CompletableFuture&lt;U&gt; doThenApply</span><br><span class="line">        (Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fn == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建新的异步结果并在该方法结束后返回这个新的异步结果。</span></span><br><span class="line">        <span class="comment">// 在当前异步结果完成时，设置这个新的异步结果，那么就像管道一样，result在这CompletableFuture组成的管道上流通。</span></span><br><span class="line">        CompletableFuture&lt;U&gt; dst = <span class="keyword">new</span> CompletableFuture&lt;U&gt;();  </span><br><span class="line">        ThenApply&lt;T,U&gt; d = <span class="keyword">null</span>;</span><br><span class="line">        Object r;</span><br><span class="line">        <span class="comment">//结果未完成时，尝试加入到操作符单向链表上</span></span><br><span class="line">        <span class="keyword">if</span> ((r = result) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            CompletionNode p = <span class="keyword">new</span> CompletionNode</span><br><span class="line">                (d = <span class="keyword">new</span> ThenApply&lt;T,U&gt;(<span class="keyword">this</span>, fn, dst, e));</span><br><span class="line">            <span class="keyword">while</span> ((r = result) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将操作符节点添加到链表头节点上，加入成功后，退出循环。</span></span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject</span><br><span class="line">                    (<span class="keyword">this</span>, COMPLETIONS, p.next = completions, p))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时，有两种情况 1. 结果已完成，2.操作符节点以成功加入链表中</span></span><br><span class="line">        <span class="comment">//加入if的临界条件：结果已完成，且操作符未执行过</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; (d == <span class="keyword">null</span> || d.compareAndSet(<span class="number">0</span>, <span class="number">1</span>))) &#123;</span><br><span class="line">            T t; Throwable ex;</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123; <span class="comment">//result是异常结果或者null。</span></span><br><span class="line">                ex = ((AltResult)r).ex; <span class="comment">//ex == null时，null结果的完成结果。 ex != null时，异常结果。</span></span><br><span class="line">                t = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//result是正常结果且非null。</span></span><br><span class="line">                ex = <span class="keyword">null</span>;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> T tr = (T) r;</span><br><span class="line">                t = tr;</span><br><span class="line">            &#125;</span><br><span class="line">            U u = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (ex == <span class="keyword">null</span>) &#123; <span class="comment">//ex == null，正常结果。另外：异常结果时，不执行操作符.</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) <span class="comment">//入参线程池 != null，操作符在线程池中执行</span></span><br><span class="line">                        execAsync(e, <span class="keyword">new</span> AsyncApply&lt;T,U&gt;(t, fn, dst));</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        u = fn.apply(t); <span class="comment">//执行操作符的操作。</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                    ex = rex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//e == null说明即再次执行操作符操作。若e != null，说明操作符在线程池e中完成，那么这个新的异步结果的结果也会在线程池e中完成</span></span><br><span class="line">             <span class="comment">//ex != null，异常结果，则不需要借用线程池执行操作符操作了</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span> || ex != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//最终把结果设置到新的异步结果上</span></span><br><span class="line">                dst.internalComplete(u, ex); </span><br><span class="line">        &#125;</span><br><span class="line">        helpPostComplete();   <span class="comment">//这个方法非常糟糕，会让操作符的回调执行所在的线程模糊。后续高版本的jdk8好像重写CompletableFuture，把它给去掉了</span></span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ThenApply对象，挂载到操作符链表上的操作跟if块的操作差不多，这里就不说了</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再看看提交到线程池e中的AsyncApply如何操作的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncApply</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt; <span class="keyword">extends</span> <span class="title">Async</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> T arg;</span><br><span class="line">            <span class="keyword">final</span> Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn;</span><br><span class="line">            <span class="keyword">final</span> CompletableFuture&lt;U&gt; dst;</span><br><span class="line">            AsyncApply(T arg, Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn,</span><br><span class="line">                       CompletableFuture&lt;U&gt; dst) &#123;</span><br><span class="line">                <span class="keyword">this</span>.arg = arg; <span class="keyword">this</span>.fn = fn; <span class="keyword">this</span>.dst = dst;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//还是跟if块的代码差不多。</span></span><br><span class="line">                <span class="comment">//这个d，就是doThenApply方法传进来的dst。</span></span><br><span class="line">                CompletableFuture&lt;U&gt; d; U u; Throwable ex;</span><br><span class="line">                <span class="keyword">if</span> ((d = <span class="keyword">this</span>.dst) != <span class="keyword">null</span> &amp;&amp; d.result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        u = fn.apply(arg);</span><br><span class="line">                        ex = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                        ex = rex;</span><br><span class="line">                        u = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    d.internalComplete(u, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5232453952276885070L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//为异步结果设置结果，典型的CAS应用</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">internalComplete</span><span class="params">(T v, Throwable ex)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">                    UNSAFE.compareAndSwapObject</span><br><span class="line">                        (<span class="keyword">this</span>, RESULT, <span class="keyword">null</span>,</span><br><span class="line">                         (ex == <span class="keyword">null</span>) ? (v == <span class="keyword">null</span>) ? NIL : v :</span><br><span class="line">                         <span class="keyword">new</span> AltResult((ex <span class="keyword">instanceof</span> CompletionException) ? ex :</span><br><span class="line">                                       <span class="keyword">new</span> CompletionException(ex)));</span><br><span class="line">                postComplete(); <span class="comment">// help out even if not triggered，非常糟糕，在这里调用帮助处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">postComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                WaitNode q; Thread t;</span><br><span class="line">                <span class="comment">//唤醒阻塞的线程节点</span></span><br><span class="line">                <span class="keyword">while</span> ((q = waiters) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, WAITERS, q, q.next) &amp;&amp;</span><br><span class="line">                        (t = q.thread) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        q.thread = <span class="keyword">null</span>;</span><br><span class="line">                        LockSupport.unpark(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//调用操作符链表上所有操作符节点，c 就是ThenApply的父类</span></span><br><span class="line">                CompletionNode h; Completion c;</span><br><span class="line">                <span class="keyword">while</span> ((h = completions) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, COMPLETIONS, h, h.next) &amp;&amp;</span><br><span class="line">                        (c = h.completion) != <span class="keyword">null</span>)</span><br><span class="line">                        c.run();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置正常结果</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">complete</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">                 <span class="comment">//如果 value == null, result 设置成 NIL.</span></span><br><span class="line">                 <span class="keyword">boolean</span> triggered = result == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                      UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, RESULT, <span class="keyword">null</span>,</span><br><span class="line">                           value == <span class="keyword">null</span> ? NIL : value);</span><br><span class="line">                      postComplete();  <span class="comment">//处理阻塞等待的线程节点和操作符，这里处理就没毛病</span></span><br><span class="line">                      <span class="keyword">return</span> triggered;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//设置异常结果</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">completeExceptionally</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">                 <span class="keyword">if</span> (ex == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">                 <span class="keyword">boolean</span> triggered = result == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, RESULT, <span class="keyword">null</span>, <span class="keyword">new</span> AltResult(ex));  <span class="comment">//异常结果用AltResult包装</span></span><br><span class="line">                 postComplete();  <span class="comment">//处理阻塞等待的线程节点和操作符，这里处理就没毛病</span></span><br><span class="line">                 <span class="keyword">return</span> triggered;</span><br><span class="line">          &#125;</span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
为什么说 helpPostComplete(), internalComplete 方法中 postComplete 方法很糟糕呢？<br>这会让操作符在哪个线程处理变得很迷，如果对一些线程敏感的代码，那么可能导致意想不到的 bug，而且不了解这一机制的话，这 bug 也很难会被发现。</li>
</ol>
<p>举个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; fut = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        fut.thenAccept(v1 -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread-name-v1 &quot;</span> + Thread.currentThread().getName()); &#125;);</span><br><span class="line"></span><br><span class="line">        fut.thenAccept(v1 -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread-name-v1 &quot;</span> + Thread.currentThread().getName()); &#125;);</span><br><span class="line"></span><br><span class="line">        fut.thenAccept(v1 -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread-name-v1 &quot;</span> + Thread.currentThread().getName()); &#125;);</span><br><span class="line"></span><br><span class="line">        fut.thenAccept(v1 -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread-name-v1 &quot;</span> + Thread.currentThread().getName()); &#125;);</span><br><span class="line"></span><br><span class="line">        fut.thenAccept(v1 -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1000L</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread-name-v1 &quot;</span> + Thread.currentThread().getName());&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="string">&quot;thread-1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; fut.complete(<span class="string">&quot;111&quot;</span>), <span class="string">&quot;thread-2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; fut.thenAccept(str -&gt; &#123;&#125;), <span class="string">&quot;thread-3&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子 println 是否啥？你猜到了吗？<br>答案是：thread-2 或者 thread-3。<br>而正常我们会认为要么是 thread-1（异步结果已完成，立即执行操作符），要么 thread-2（设置结果时，处理操作符）</p>
<ol start="2">
<li><p>zipWith 操作符 == thenCombine<br>当前的 CompletableFuture 和 other CompletableFuture 同时完成时，执行操作符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine</span><br><span class="line">    (CompletionStage&lt;? extends U&gt; other,</span><br><span class="line">     BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> doThenCombine(other.toCompletableFuture(), fn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要当前的CompletableFuture和other同时完成时，才调用操作符</span></span><br><span class="line"><span class="keyword">private</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; doThenCombine</span><br><span class="line">    (CompletableFuture&lt;? extends U&gt; other,</span><br><span class="line">     BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn,</span><br><span class="line">     Executor e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">null</span> || fn == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    CompletableFuture&lt;V&gt; dst = <span class="keyword">new</span> CompletableFuture&lt;V&gt;();  <span class="comment">//还是跟上面分析的一样，最后它</span></span><br><span class="line">    ThenCombine&lt;T,U,V&gt; d = <span class="keyword">null</span>;</span><br><span class="line">    Object r, s = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当任意其中一个异步结果未完成时，进入if块</span></span><br><span class="line">    <span class="keyword">if</span> ((r = result) == <span class="keyword">null</span> || (s = other.result) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        d = <span class="keyword">new</span> ThenCombine&lt;T,U,V&gt;(<span class="keyword">this</span>, other, fn, dst, e);</span><br><span class="line">        CompletionNode q = <span class="keyword">null</span>, p = <span class="keyword">new</span> CompletionNode(d);</span><br><span class="line">        <span class="keyword">while</span> ((r == <span class="keyword">null</span> &amp;&amp; (r = result) == <span class="keyword">null</span>) ||</span><br><span class="line">               (s == <span class="keyword">null</span> &amp;&amp; (s = other.result) == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//第一次进来时，q == null，先执行 else-if</span></span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s != <span class="keyword">null</span> ||</span><br><span class="line">                    UNSAFE.compareAndSwapObject</span><br><span class="line">                    (other, COMPLETIONS, q.next = other.completions, q))  <span class="comment">//other异步结果未完成时，挂载到操作符链表上</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (r != <span class="keyword">null</span> ||</span><br><span class="line">                     UNSAFE.compareAndSwapObject</span><br><span class="line">                     (<span class="keyword">this</span>, COMPLETIONS, p.next = completions, p)) &#123;  <span class="comment">//当前异步结果未完成时，挂载到操作符链表上</span></span><br><span class="line">                <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q = <span class="keyword">new</span> CompletionNode(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当两个异步结果都完成时，且操作符还未执行时，进入if块</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; s != <span class="keyword">null</span> &amp;&amp; (d == <span class="keyword">null</span> || d.compareAndSet(<span class="number">0</span>, <span class="number">1</span>))) &#123;</span><br><span class="line">        T t; U u; Throwable ex;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123; <span class="comment">//第一个异步结果 异常完成或null</span></span><br><span class="line">            ex = ((AltResult)r).ex;</span><br><span class="line">            t = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ex = <span class="keyword">null</span>;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> T tr = (T) r;</span><br><span class="line">            t = tr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="keyword">null</span>) <span class="comment">//说明第一个结果异常了，那么就不用去获取第二个异步结果的结果了。</span></span><br><span class="line">            u = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">            ex = ((AltResult)s).ex;</span><br><span class="line">            u = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> U us = (U) s;</span><br><span class="line">            u = us;</span><br><span class="line">        &#125;</span><br><span class="line">        V v = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ex == <span class="keyword">null</span>) &#123; <span class="comment">//当两个异步结果都正常完成时，执行操作符</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) <span class="comment">//上面分析过了</span></span><br><span class="line">                    execAsync(e, <span class="keyword">new</span> AsyncCombine&lt;T,U,V&gt;(t, u, fn, dst));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    v = fn.apply(t, u);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                ex = rex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终把结果设置到新的异步结果上</span></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span> || ex != <span class="keyword">null</span>) </span><br><span class="line">            dst.internalComplete(v, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    helpPostComplete();</span><br><span class="line">    other.helpPostComplete();</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>thenCombine 方法，会到操作符的操作 ThenCombine 同时挂载到两个异步结果的操作符链表中。通过 CAS 控制，只有一次机会执行操作符操作。<br>ThenCombine 跟 if 块的代码类似，就不展开说了。</p>
</li>
<li><p>(ambWith &amp;&amp; map) == applyToEither<br>当前的 CompletableFuture 跟 other CompletableFuture任意一个完成时，执行操作符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; applyToEither</span><br><span class="line">    (CompletionStage&lt;? extends T&gt; other,</span><br><span class="line">     Function&lt;? <span class="keyword">super</span> T, U&gt; fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> doApplyToEither(other.toCompletableFuture(), fn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;U&gt; CompletableFuture&lt;U&gt; doApplyToEither</span><br><span class="line">        (CompletableFuture&lt;? extends T&gt; other,</span><br><span class="line">         Function&lt;? <span class="keyword">super</span> T, U&gt; fn,</span><br><span class="line">         Executor e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="keyword">null</span> || fn == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        CompletableFuture&lt;U&gt; dst = <span class="keyword">new</span> CompletableFuture&lt;U&gt;();</span><br><span class="line">        ApplyToEither&lt;T,U&gt; d = <span class="keyword">null</span>;</span><br><span class="line">        Object r;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当前异步结果和other 异步结果都未完成时，进入if块</span></span><br><span class="line">        <span class="keyword">if</span> ((r = result) == <span class="keyword">null</span> &amp;&amp; (r = other.result) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            d = <span class="keyword">new</span> ApplyToEither&lt;T,U&gt;(<span class="keyword">this</span>, other, fn, dst, e);</span><br><span class="line">            CompletionNode q = <span class="keyword">null</span>, p = <span class="keyword">new</span> CompletionNode(d);</span><br><span class="line">            <span class="keyword">while</span> ((r = result) == <span class="keyword">null</span> &amp;&amp; (r = other.result) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (UNSAFE.compareAndSwapObject</span><br><span class="line">                        (other, COMPLETIONS, q.next = other.completions, q))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//先挂载到当前异步结果上，</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (UNSAFE.compareAndSwapObject</span><br><span class="line">                         (<span class="keyword">this</span>, COMPLETIONS, p.next = completions, p))</span><br><span class="line">                    q = <span class="keyword">new</span> CompletionNode(d);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时，r可能来自result，也有可能来自other.result。</span></span><br><span class="line">        <span class="comment">//当两个异步结果都未完成时且操作符未执行过。</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; (d == <span class="keyword">null</span> || d.compareAndSet(<span class="number">0</span>, <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="comment">//到这里就跟doThenApply基本一样了，就不展开分析了</span></span><br><span class="line">            T t; Throwable ex;</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">                ex = ((AltResult)r).ex;</span><br><span class="line">                t = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ex = <span class="keyword">null</span>;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> T tr = (T) r;</span><br><span class="line">                t = tr;</span><br><span class="line">            &#125;</span><br><span class="line">            U u = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (ex == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">                        execAsync(e, <span class="keyword">new</span> AsyncApply&lt;T,U&gt;(t, fn, dst));</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        u = fn.apply(t);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                    ex = rex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span> || ex != <span class="keyword">null</span>)</span><br><span class="line">                dst.internalComplete(u, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        helpPostComplete();</span><br><span class="line">        other.helpPostComplete();</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>flatMap == thenCompose</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; thenCompose</span><br><span class="line">    (Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> doThenCompose(fn, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;U&gt; CompletableFuture&lt;U&gt; doThenCompose</span><br><span class="line">        (Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn,</span><br><span class="line">         Executor e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fn == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        CompletableFuture&lt;U&gt; dst = <span class="keyword">null</span>;</span><br><span class="line">        ThenCompose&lt;T,U&gt; d = <span class="keyword">null</span>;</span><br><span class="line">        Object r;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当前结果未完成时，尝试挂载到当前异步结果上</span></span><br><span class="line">        <span class="keyword">if</span> ((r = result) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            dst = <span class="keyword">new</span> CompletableFuture&lt;U&gt;();</span><br><span class="line">            CompletionNode p = <span class="keyword">new</span> CompletionNode</span><br><span class="line">                (d = <span class="keyword">new</span> ThenCompose&lt;T,U&gt;(<span class="keyword">this</span>, fn, dst, e));</span><br><span class="line">            <span class="keyword">while</span> ((r = result) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject</span><br><span class="line">                    (<span class="keyword">this</span>, COMPLETIONS, p.next = completions, p))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当前异步结果已完成时，且操作符未执行过</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; (d == <span class="keyword">null</span> || d.compareAndSet(<span class="number">0</span>, <span class="number">1</span>))) &#123;</span><br><span class="line">            T t; Throwable ex;</span><br><span class="line">            <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">                ex = ((AltResult)r).ex;</span><br><span class="line">                t = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ex = <span class="keyword">null</span>;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> T tr = (T) r;</span><br><span class="line">                t = tr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//异步结果，正常完成</span></span><br><span class="line">            <span class="keyword">if</span> (ex == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dst == <span class="keyword">null</span>)</span><br><span class="line">                        dst = <span class="keyword">new</span> CompletableFuture&lt;U&gt;();</span><br><span class="line">                    execAsync(e, <span class="keyword">new</span> AsyncCompose&lt;T,U&gt;(t, fn, dst));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//返回新的异步结果，正常情况下，doThenCompose方法返回的是这个异步结果。</span></span><br><span class="line">                        CompletionStage&lt;U&gt; cs = fn.apply(t); </span><br><span class="line">                        <span class="keyword">if</span> (cs == <span class="keyword">null</span> ||</span><br><span class="line">                            (dst = cs.toCompletableFuture()) == <span class="keyword">null</span>)</span><br><span class="line">                            ex = <span class="keyword">new</span> NullPointerException();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                        ex = rex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (dst == <span class="keyword">null</span>)</span><br><span class="line">                dst = <span class="keyword">new</span> CompletableFuture&lt;U&gt;();</span><br><span class="line">            <span class="comment">//异步结果异常完成时，或者执行操作符时发生异常，通知新的异步结果。</span></span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="keyword">null</span>)</span><br><span class="line">                dst.internalComplete(<span class="keyword">null</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        helpPostComplete();</span><br><span class="line">        dst.helpPostComplete();</span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后面的 exceptionally，whenComplete，handle，实现就跟 thenApply 差不多。这里就不展开说了。<br>CompletableFuture 源码的核心流程都已经覆盖完了。</p>
</li>
<li><p>即使 CompletionStage，CompletableFuture 怎么怎么不好，但没办法，这是标准库的类（亲儿子）。所以做好跟标准库的兼容还是有必要的。可以很方便和其他实现 CompletionStage 的框架或类库做集成。</p>
</li>
</ol>
<p>写了点异步相关的基础库，之前想直接继承 CompletableFuture 做拓展就行了。后面发现了上面所说的它回调机制的坑，<br>所以就自己重写了一个 CompletionStage。<br>总体上，还是非常简单的。基于回调(addHandler)的方式，把上面的所有操作符都实现了。源码在这里。<a target="_blank" rel="noopener" href="https://github.com/wang007/pandora/blob/master/pandora-ext/src/main/java/com/github/pandora/asyncResult/CompletableResult.java">CompletableResult</a></p>
<hr>
<p>还是上一篇文章说过，异步往往伴随着回调。而且还举了一个回调嵌套（callback hell）的例子，这个我们就会CompletableFuture改善一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">startServer(socket -&gt; &#123;</span><br><span class="line">            socket.read()</span><br><span class="line">                    .thenCompose(str -&gt; &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;result -&gt; &quot;</span> + str);</span><br><span class="line">                        <span class="keyword">return</span> socket.write(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .thenCompose(v -&gt; &#123;</span><br><span class="line">                        <span class="keyword">return</span> socket.write(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .thenCompose(v -&gt; &#123;</span><br><span class="line">                        <span class="keyword">return</span> socket.write(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .whenComplete((v, err) -&gt; &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;socket close&quot;</span>);</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>这个看起来是不是简洁了很多。callback hell 会被平铺（flat）了。这个代码跟上篇文章的回调嵌套执行结果是一样的。</p>
<p>下面是如何实现的。可以看到改动也是非常小的，但是对使用方的效果完成不一样，可阅读性好非常多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletionStage&lt;String&gt; <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">           read(obj -&gt; &#123;</span><br><span class="line">               <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                   future.complete((String) obj);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   future.completeExceptionally(obj == <span class="keyword">null</span> ? <span class="keyword">new</span> NullPointerException() : (Throwable) obj);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="keyword">return</span> future;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">write</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">           CompletableFuture&lt;Void&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">           write(data, obj -&gt; &#123;</span><br><span class="line">               <span class="keyword">if</span>(obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   future.complete(<span class="keyword">null</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   future.completeExceptionally(obj == <span class="keyword">null</span> ? <span class="keyword">new</span> NullPointerException() : (Throwable) obj);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="keyword">return</span> future;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个例子，包含前面说到的自实现的 CompletionStage，ListenableFuture 也好，都是通过回调扩展出来的，所以只有回调这最原始的 api，就可以做无限的拓展。</p>
<h4 id="所以异步非阻塞框架，都是基于这种回调的方式，然后通过各种手段不断地去解决回调嵌套的问题。下面即将讲到的响应式编程，协程，也是如此。"><a href="#所以异步非阻塞框架，都是基于这种回调的方式，然后通过各种手段不断地去解决回调嵌套的问题。下面即将讲到的响应式编程，协程，也是如此。" class="headerlink" title="所以异步非阻塞框架，都是基于这种回调的方式，然后通过各种手段不断地去解决回调嵌套的问题。下面即将讲到的响应式编程，协程，也是如此。"></a>所以异步非阻塞框架，都是基于这种回调的方式，然后通过各种手段不断地去解决回调嵌套的问题。下面即将讲到的响应式编程，协程，也是如此。</h4><p>总结：</p>
<ol>
<li>Future 的源码分析。</li>
<li>如何基于 Future，改成基于回调机制的 Future。</li>
<li>CompletionStage，CompletableFuture 的源码分析，分类总结。</li>
<li>如何简单的实现一个 CompletionStage。(<a target="_blank" rel="noopener" href="https://www.github.com/wang007/pandora">pandora</a>)</li>
<li>CompletionStage 使用方式和如何改善 callback hell。</li>
</ol>
<hr>
<p>好了，晚安。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag"># 异步</a>
              <a href="/tags/CompletionStage/" rel="tag"># CompletionStage</a>
              <a href="/tags/CompletableFuture/" rel="tag"># CompletableFuture</a>
              <a href="/tags/ListenableFuture/" rel="tag"># ListenableFuture</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/java-async-road-3/" rel="prev" title="java 异步编程探究-响应式编程">
                  <i class="fa fa-chevron-left"></i> java 异步编程探究-响应式编程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/java-async-road/" rel="next" title="java 异步编程探究普拉斯">
                  java 异步编程探究普拉斯 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wang007</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

</body>
</html>
