<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"8.0.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="零 大多数 java 开发者应该都使用过 maven，但是 gradle 就比较少接触了。 maven 上手是比较简单的。 gradle 上手成本是比较高的，但一旦熟悉 gradle 之后那么对于灵活构建项目是非常方便。对于构建项目领域，gradle 比 maven 先进太多了。 本文章假设你了解 groovy，如果不熟悉 groovy 的话可以先了解 groovy。对于有 java 基础的同学来">
<meta property="og:type" content="article">
<meta property="og:title" content="gradle 上手">
<meta property="og:url" content="http://example.com/gradle-get-started/index.html">
<meta property="og:site_name" content="wang007 blog">
<meta property="og:description" content="零 大多数 java 开发者应该都使用过 maven，但是 gradle 就比较少接触了。 maven 上手是比较简单的。 gradle 上手成本是比较高的，但一旦熟悉 gradle 之后那么对于灵活构建项目是非常方便。对于构建项目领域，gradle 比 maven 先进太多了。 本文章假设你了解 groovy，如果不熟悉 groovy 的话可以先了解 groovy。对于有 java 基础的同学来">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://docs.gradle.org/current/userguide/img/java-main-configurations.png">
<meta property="article:published_time" content="2021-01-02T07:22:10.000Z">
<meta property="article:modified_time" content="2021-01-03T17:34:16.629Z">
<meta property="article:author" content="wang007">
<meta property="article:tag" content="java">
<meta property="article:tag" content="gradle">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://docs.gradle.org/current/userguide/img/java-main-configurations.png">


<link rel="canonical" href="http://example.com/gradle-get-started/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>gradle 上手 | wang007 blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">wang007 blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6"><span class="nav-number">1.</span> <span class="nav-text">零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#maven"><span class="nav-number">2.</span> <span class="nav-text">maven</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gradle"><span class="nav-number">3.</span> <span class="nav-text">gradle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">3.1.</span> <span class="nav-text">1. 示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-gradle-wrapper"><span class="nav-number">3.2.</span> <span class="nav-text">2. gradle wrapper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-gradle-%E5%A3%B0%E6%98%8E-jar-%E4%BE%9D%E8%B5%96"><span class="nav-number">3.3.</span> <span class="nav-text">3. gradle 声明 jar 依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-gradle-task"><span class="nav-number">3.4.</span> <span class="nav-text">4. gradle task</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#task-%E5%A3%B0%E6%98%8E"><span class="nav-number">3.4.1.</span> <span class="nav-text">task 声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#task-%E9%85%8D%E7%BD%AE%E9%98%B6%E6%AE%B5%E5%92%8C%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5"><span class="nav-number">3.4.2.</span> <span class="nav-text">task 配置阶段和执行阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UP-TO-DATE"><span class="nav-number">3.4.3.</span> <span class="nav-text">UP-TO-DATE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-gradle-%E5%B8%B8%E7%94%A8-api"><span class="nav-number">3.5.</span> <span class="nav-text">6. gradle 常用 api</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-buildscript"><span class="nav-number">3.5.1.</span> <span class="nav-text">1. buildscript</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-repositories-%E5%92%8C-dependencies"><span class="nav-number">3.5.2.</span> <span class="nav-text">2. repositories 和 dependencies</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-plugin"><span class="nav-number">3.5.3.</span> <span class="nav-text">3. plugin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-subprojects-%E5%92%8C-allprojects"><span class="nav-number">3.5.4.</span> <span class="nav-text">4. subprojects 和 allprojects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-task"><span class="nav-number">3.5.5.</span> <span class="nav-text">5. task</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-file-%E5%92%8C-dir-%E7%9B%B8%E5%85%B3-api"><span class="nav-number">3.5.6.</span> <span class="nav-text">6. file 和 dir 相关 api</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-gradle-plugin"><span class="nav-number">3.6.</span> <span class="nav-text">7. gradle plugin</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-gradle-plugin"><span class="nav-number">3.6.1.</span> <span class="nav-text">自定义 gradle plugin</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-gradle-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">3.7.</span> <span class="nav-text">8. gradle 生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A5%E9%81%93-gradle-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E5%91%A2%EF%BC%9F"><span class="nav-number">3.7.1.</span> <span class="nav-text">知道 gradle 生命周期 有什么用呢？</span></a></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">wang007</p>
  <div class="site-description" itemprop="description">wang007 blog</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/gradle-get-started/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="wang007">
      <meta itemprop="description" content="wang007 blog">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wang007 blog">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          gradle 上手
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-02 15:22:10" itemprop="dateCreated datePublished" datetime="2021-01-02T15:22:10+08:00">2021-01-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-04 01:34:16" itemprop="dateModified" datetime="2021-01-04T01:34:16+08:00">2021-01-04</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="零"><a href="#零" class="headerlink" title="零"></a>零</h2><ol>
<li>大多数 java 开发者应该都使用过 maven，但是 gradle 就比较少接触了。</li>
<li>maven 上手是比较简单的。</li>
<li>gradle 上手成本是比较高的，但一旦熟悉 gradle 之后那么对于灵活构建项目是非常方便。对于构建项目领域，<br>gradle 比 maven 先进太多了。</li>
<li>本文章假设你了解 groovy，如果不熟悉 groovy 的话可以先了解 groovy。对于有 java 基础的同学来说上手 groovy 基本是零成本的。</li>
</ol>
<a id="more"></a>

<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p>maven 是有固定项目构建生命周期。一般只需要配置好依赖和插件即可。想要灵活构建项目就会很麻烦。<br>这里不深究 maven 相关的东西，直接来上手 gradle。</p>
<h2 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h2><p>gradle 是没有固定的项目构建生命周期，而非常巧妙地使用 task 依赖关系来模拟出 “项目构建生命周期”。<br>接下来就按照以下顺序来讲解 gradle 。 </p>
<ol>
<li>示例代码</li>
<li>gradle wrapper</li>
<li>gradle 声明 jar 依赖</li>
<li>gradle task</li>
<li>模块化</li>
<li>gradle 常用 api </li>
<li>gradle plugin</li>
<li>gradle 生命周期</li>
</ol>
<h3 id="1-示例代码"><a href="#1-示例代码" class="headerlink" title="1. 示例代码"></a>1. 示例代码</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">&quot;https://maven.aliyun.com/repository/public&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;org.springframework.boot:spring-boot-gradle-plugin:2.3.7.RELEASE&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&quot;java&quot;</span></span><br><span class="line">    id <span class="string">&quot;idea&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&quot;org.springframework.boot&quot;</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    maven &#123;</span><br><span class="line">        url <span class="string">&quot;https://maven.aliyun.com/repository/public&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.cloud:spring-cloud-starter-gateway:2.2.6.RELEASE&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 spring-cloud-gateway 网关项目跑起来的 build.gradle 。</p>
<hr>
<h3 id="2-gradle-wrapper"><a href="#2-gradle-wrapper" class="headerlink" title="2. gradle wrapper"></a>2. gradle wrapper</h3><p>gradle wrapper 为了适配不同版本的 gradle，有了 wrapper 就可以快速切换不同的版本。从而适配项目的变化。<br>每个 gradle 项目都有会如下结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">│</span><br><span class="line">├── ... </span><br><span class="line">│</span><br><span class="line">├── grale  --&gt; wrapper 目录</span><br><span class="line">│    ├── gradle-wrapper.jar </span><br><span class="line">│    └── gradle-wrapper.properties</span><br><span class="line">│</span><br><span class="line">├── gradlew --&gt; linux &#x2F; mac 执行 gradle 入口</span><br><span class="line">└── gradlew --&gt; windows 执行 gradle 入口</span><br></pre></td></tr></table></figure>
<ol>
<li>执行 gradle 命名： ./gradle task-name 即可。  </li>
<li>这里最主要的是 radle-wrapper.properties， 指定 gradle 版本，或者修改 gradle daemon jvm 内存大小等。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 指定 gradle 版本为 6.7 如果项目使用 5.6 的版本，只需要把 6.7 改成 5.6 即可。</span><br><span class="line"># all 是包括源码和文档的 gradle。 bin 是只有二进制包。这里强烈推荐使用 all</span><br><span class="line">distributionUrl&#x3D;https\:&#x2F;&#x2F;services.gradle.org&#x2F;distributions&#x2F;gradle-6.7-all.zip </span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="3-gradle-声明-jar-依赖"><a href="#3-gradle-声明-jar-依赖" class="headerlink" title="3. gradle 声明 jar 依赖"></a>3. gradle 声明 jar 依赖</h3><p>如上面的例子，在 dependencies 中声明依赖。除了可以使用 implementation 声明依赖。还可以使用 compileOnly,RuntimeOnly 声明仅仅编译期依赖，仅仅运行期依赖<br><img src="https://docs.gradle.org/current/userguide/img/java-main-configurations.png" alt="gradle java plugin"></p>
<ol>
<li>最终执行编译工作的 task compileJava 间接依赖了 compileOnly，implementation。</li>
<li>也就是说，implementation 是编译期和运行期都依赖，相当于 maven scope = compile</li>
<li>其中 compile 声明在高版本已经不推荐使用了。</li>
</ol>
<p>原理：</p>
<ol>
<li>之所以能用这些声明，是因为 Java plugin 定义了这些声明依赖的方法。</li>
<li>Java plugin 通过 project#ConfigurationContainer 定义了 Configuration。例如 implementation 是一个 Configuration。</li>
<li>在 dependencies 使用声明 implementation 依赖，最终通过 groovy methodMissing 原理传给了 ConfigurationContainer 的 implementation Configuration。</li>
<li>最终结果相当于<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    add(&quot;implementation&quot;, &quot;org.springframework.cloud:spring-cloud-starter-gateway:2.2.6.RELEASE&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="4-gradle-task"><a href="#4-gradle-task" class="headerlink" title="4. gradle task"></a>4. gradle task</h3><p>task 是 gradle 最核心的组件，gradle 所有的构建工作都是指定执行某个 task。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;gradlw build &#x2F;&#x2F;执行 build 这个 task</span><br><span class="line">.&#x2F;gradlew compileJava 执行编译 java 这个 task</span><br></pre></td></tr></table></figure>
<p>task 通过 dependOn 方法声明 task 之间的依赖。 哪怕 task 不是由自己自定义的。<br>task 通过声明依赖关系，最终 task 会组成一个 DAG（有向无环图），如果存在循环依赖 gradle 会报错。<br>例如： </p>
<ol>
<li>项目中通过 version 插件生成一个 git version 信息并打进 fat jar 中，这样就很明确知道当前 jar 是什么 git commit。</li>
<li>那么只需要把 version 文件生成到 build/resources 目录中， 而在执行 processResources task 之前声明执行生成 version task 即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; versionFile 是在 net.nemerosa.versioning plugin 声明的 task</span><br><span class="line">project.tasks.getByName(&quot;versionFile&quot;) &#123;</span><br><span class="line">   file &#x3D; new File(project.buildDir, &#39;resources&#x2F;main&#x2F;version.properties&#39;)</span><br><span class="line">&#125;        </span><br><span class="line">Task processResources &#x3D; project.tasks.findByName(&quot;processResources&quot;)</span><br><span class="line">processResources.dependsOn(&quot;versionFile&quot;)</span><br></pre></td></tr></table></figure>
这样执行 processResources task 之前，就会先执行 versionFile。</li>
</ol>
<h4 id="task-声明"><a href="#task-声明" class="headerlink" title="task 声明"></a>task 声明</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">task printName &#123;</span><br><span class="line">    println(it.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tasks.create(<span class="string">&quot;printName&quot;</span>) &#123;</span><br><span class="line">    println(it.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上两种声明方式是一样的效果。</p>
<h4 id="task-配置阶段和执行阶段"><a href="#task-配置阶段和执行阶段" class="headerlink" title="task 配置阶段和执行阶段"></a>task 配置阶段和执行阶段</h4><p>上例两个 task 的 println 方法是在配置阶段执行的，也就是说 {} 代码最终包装到 task#configure 方法中。 相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasks.create(&quot;printName&quot;).configure &#123;</span><br><span class="line">    println(it.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 configure 方法中做对 task 任何配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tasks.create(&quot;printName&quot;).configure &#123;</span><br><span class="line">    dependsOn(&quot;compileJava&quot;)  &#x2F;&#x2F; 声明当前 task 依赖 compileJava</span><br><span class="line">    group &quot;print&quot;             &#x2F;&#x2F; 声明 task 所属的 group</span><br><span class="line">    onlyIf &#123; true &#125;           &#x2F;&#x2F; 声明 task 在什么条件下执行，这里直接返回 true，即任何条件下</span><br><span class="line">    inputs.dir(new File(project.buildDir, &quot;classes&quot;)) &#x2F;&#x2F;声明 task 输入</span><br><span class="line">    outputs.dir(new File(project.buildDir, &quot;resources&quot;)) &#x2F;&#x2F;声明 task 输出</span><br><span class="line">    </span><br><span class="line">    doFirst &#123;</span><br><span class="line">        println &quot;doFirst&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        println &quot;doLast&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doFirst, doLast 方法就是声明 task 执行期的操作。也就是说 ./gradlew printName, 会先后输出 doFirst，doLast。<br>每个 task 可以通过 doFirst，doLast 方法声明多个 action。</p>
<h4 id="UP-TO-DATE"><a href="#UP-TO-DATE" class="headerlink" title="UP-TO-DATE"></a>UP-TO-DATE</h4><ol>
<li>task 是存在缓存的，也就是说 task 是最新的话，那么会跳过执行 task 去执行下一个 task。  </li>
<li>而 判断 task 是否最新通过 inputs，outputs 来判断的。 gradle 会自动判断 inputs，outputs 声明的目录或文件是否有更新。</li>
<li>如何关闭缓存。<ol>
<li>不声明 inputs，outputs。</li>
<li>配置 outputs。</li>
<li>通过 干扰 inputs，outputs 对应的目录或文件。例如 outputs 目录生成的文件删除掉，inputs 目录中内容的更新一下。</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 对 outputs 配置下面任何一个即可关闭缓存。</span><br><span class="line">outputs.cacheIf &#123;</span><br><span class="line">   false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outputs.upToDateWhen &#123;</span><br><span class="line">   false</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">---</span><br><span class="line">### 5. 模块化</span><br><span class="line">在 项目根目录下 settings.gradle 中声明项目的模块，gradle 通过这种方式非常方便的支持模块化项目。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;groovy</span><br><span class="line">&#x2F;&#x2F; settings.gradle</span><br><span class="line">rootProject.name &#x3D; &#39;platform-starter&#39;</span><br><span class="line">include &#39;proto&#39;</span><br><span class="line">include &#39;server&#39;</span><br></pre></td></tr></table></figure>
<p>声明当前项目包括 proto，server 两个模块。<br>在 gradle 定义里一个模块就是一个 project，project 之间有父子关系。例如 platform-starter 有两个 sub project：proto，server。在 project api 会体现。<br>当然模块中还可以再继续定义模块。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// settings.gradle</span></span><br><span class="line">include <span class="string">&#x27;proto&#x27;</span></span><br><span class="line">include <span class="string">&#x27;proto:abc&#x27;</span></span><br><span class="line">include <span class="string">&#x27;proto:xyz&#x27;</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="6-gradle-常用-api"><a href="#6-gradle-常用-api" class="headerlink" title="6. gradle 常用 api"></a>6. gradle 常用 api</h3><p>首先 gradle 项目，最先关注和使用的是 build.gradle，而 build.gradle 通过 groovy dsl 的方式定义一个 project 对象。<br>先梳理 project 常用方法</p>
<ol>
<li>buildscript</li>
<li>repositories 和 dependencies</li>
<li>plugins</li>
<li>subprojects 和 allprojects</li>
<li>task</li>
<li>file 和 dir 相关 api</li>
</ol>
<h4 id="1-buildscript"><a href="#1-buildscript" class="headerlink" title="1. buildscript"></a>1. buildscript</h4><ol>
<li>buildscript 主要是用来声明 gradle 本身的依赖。例如 依赖第三方库的插件，写 build.gradle 本身需要依赖第三方 jar。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &quot;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;org.springframework.boot:spring-boot-gradle-plugin:2.3.7.RELEASE&quot;</span><br><span class="line">        classpath &quot;org.apache.commons:commons-lang3:3.11&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
repositories 声明依赖的 maven 仓库源，对于第三方库插件本身也是普通的 jar。<br>dependencies 声明依赖，这里只能使用 classpath 声明。 例如依赖 spring boot 插件，依赖 commons-lang3 包在接下来 build.gradle 对字符串进行处理。</li>
</ol>
<h4 id="2-repositories-和-dependencies"><a href="#2-repositories-和-dependencies" class="headerlink" title="2. repositories 和 dependencies"></a>2. repositories 和 dependencies</h4><p>项目本身的 maven 仓库源和依赖声明。<br>buildscript 和 project 的 repositories，dependencies，可能是最容易让初学者困惑的。<br>这里最主要的区别是 一个gradle 构建脚本自身的依赖，一个项目本身的依赖。  </p>
<h4 id="3-plugin"><a href="#3-plugin" class="headerlink" title="3. plugin"></a>3. plugin</h4><p>引入 plugin 通常有两种方式。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 这种方式引入的 plugin，plugin 默认会从 gradle 官方 plugin 仓库中找。而 java，idea 已经集成到代码中了。</span></span><br><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&quot;java&quot;</span></span><br><span class="line">    id <span class="string">&quot;idea&quot;</span></span><br><span class="line">    id <span class="string">&quot;org.springframework.boot&quot;</span> version <span class="string">&quot;2.3.7.RELEASE&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. </span></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenLocal()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">&quot;https://maven.aliyun.com/repository/public&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">&quot;org.springframework.boot:spring-boot-gradle-plugin:2.3.7.RELEASE&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&quot;java&quot;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&quot;idea&quot;</span></span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&quot;org.springframework.boot&quot;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>第一种方式会引入插件并自动 apply plugin 了，当然可以关闭自动 apply<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &quot;org.springframework.boot&quot; version &quot;2.3.7.RELEASE&quot; apply false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二种需要在 buildscript # dependencies 声明插件的 maven 插件，然后在手动 apply 依赖，这种方式显然没有第一种方式简洁。</li>
</ol>
<h4 id="4-subprojects-和-allprojects"><a href="#4-subprojects-和-allprojects" class="headerlink" title="4. subprojects 和 allprojects"></a>4. subprojects 和 allprojects</h4><p>前面说到，每个模块都是一个 project。这些模块很大部分配置都是一样，如果每个项目都配置一遍，就是重复配置和冗余的代码。<br>而 subprojects 和 allprojects 可以解决上述的痛点。</p>
<ol>
<li>subprojects: 当前项目的所有子项目。         exclude current project</li>
<li>allprojects: 当前项目和当前项目的所有子项目。 include current project</li>
<li>例如给所有的子项目配置 lang3 的依赖：<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在根目录下的 build.gradle </span></span><br><span class="line">subprojects &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        implementation <span class="string">&#x27;org.springframework.cloud:spring-cloud-starter-gateway:2.2.6.RELEASE&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
subprojects 代码块中的入餐是 project，dependencies 方法的调用会代理给这个入参 project。<br>很显然这个方法的代码块会被执行多次，根据 sub project 解决执行多少次。</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rootProject.name = <span class="string">&#x27;platform-starter&#x27;</span></span><br><span class="line">include <span class="string">&#x27;proto&#x27;</span></span><br><span class="line">include <span class="string">&#x27;proto:abc&#x27;</span></span><br><span class="line">include <span class="string">&#x27;proto:xyz&#x27;</span></span><br><span class="line">include <span class="string">&#x27;server&#x27;</span></span><br></pre></td></tr></table></figure>
<p>以这种项目结构为例，项目的 allprojects 和 subprojects 的关系</p>
<ol>
<li>platform-starter<br>allprojects: platform-starter, proto, proto:abc, proto:xyz, server<br>subprojects: proto, proto:abc, proto:xyz, server</li>
<li>proto<br>allprojects: proto, proto:abc, proto:xyz, server<br>subprojects: proto:xyz, server</li>
</ol>
<p>project api 也可以获取 project 的关联 project</p>
<ol>
<li>getSubprojects: 获取当前项目的所有子项目</li>
<li>getParent: 获取当前项目的直接父项目</li>
<li>…: 还有其他 project 查询 project api</li>
</ol>
<h4 id="5-task"><a href="#5-task" class="headerlink" title="5. task"></a>5. task</h4><ol>
<li>getTasks(): 获取当前项目的所有 task，返回 TaskContainer。TaskContainer 作为 task 容器，有很多关于 task 增删改查的 api。</li>
<li>task 方法<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task([<span class="attr">group:</span> <span class="string">&quot;print&quot;</span>, <span class="attr">type:</span> Copy, <span class="attr">dependsOn:</span> <span class="string">&quot;otherTask&quot;</span>], <span class="string">&quot;printCopy&quot;</span>) &#123;</span><br><span class="line">    println(it.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然 type 声明不能 configure 里</span></span><br><span class="line">task(<span class="string">&quot;printCopy1&quot;</span>) &#123;</span><br><span class="line">    group(<span class="string">&quot;print&quot;</span>)</span><br><span class="line">    dependsOn <span class="string">&quot;otherTask&quot;</span></span><br><span class="line">    println(it.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-file-和-dir-相关-api"><a href="#6-file-和-dir-相关-api" class="headerlink" title="6. file 和 dir 相关 api"></a>6. file 和 dir 相关 api</h4></li>
<li>getBuildDir: 获取构建当前项目的构建目录路径</li>
<li>setBuildDir: 设置当前项目的构建目录路径</li>
<li>getRootDir: 获取根项目的目录路径</li>
<li>getProjectDir: 获取当前项目的目录路径</li>
<li>file(Object path): 获取指定路径的 File，路径可以是相对于当前项目，可以是绝对路径。</li>
<li>fileTree(Object baseDir): 指定 base 路径，返回以基路径的 fileTree，fileTree 功能很强大，提供很多文件过滤，匹配相关的方法。</li>
</ol>
<hr>
<h3 id="7-gradle-plugin"><a href="#7-gradle-plugin" class="headerlink" title="7. gradle plugin"></a>7. gradle plugin</h3><p>如果掌握了上述 project api，那么对于 gradle plugin 是非常简单的。<br>先看 plugin api 定义： </p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Plugin</span>&lt;<span class="title">T</span>&gt; &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Apply this plugin to the given target object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param target The target object</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> apply(T target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>范型 T，就是 Project。  </p>
<ol>
<li>所以 apply plugin: “some-plugin”，就是把当前 project 传给 plugin 实例然后执行 apply(project) 方法</li>
<li>apply 方法里，拿到 project 实例就可以做任意的事情。</li>
</ol>
<h4 id="自定义-gradle-plugin"><a href="#自定义-gradle-plugin" class="headerlink" title="自定义 gradle plugin"></a>自定义 gradle plugin</h4><ol>
<li><p>直接在 build.gradle 定义 Plugin，这种方式在正式项目基本很少用。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreetingPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        project.task(<span class="string">&#x27;hello&#x27;</span>) &#123;</span><br><span class="line">            doLast &#123;</span><br><span class="line">                println <span class="string">&#x27;Hello from the GreetingPlugin&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply the plugin</span></span><br><span class="line">apply <span class="attr">plugin:</span> GreetingPlugin</span><br></pre></td></tr></table></figure>
<p>./gradlew hello 执行 task 即可看到 println 结果。<br>就在我写这个例子的时候发现一个 bug。= =  <a target="_blank" rel="noopener" href="https://github.com/gradle/gradle/issues/15673">custom plugin failed in build.gradle </a></p>
</li>
<li><p>在独立项目中开发 plugin，最终打成 jar 包给其他项目使用。这种方式最常使用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">│</span><br><span class="line">├── ... </span><br><span class="line">│</span><br><span class="line">├──src</span><br><span class="line">│    └── main</span><br><span class="line">│         ├── groovy</span><br><span class="line">│         │   └── com</span><br><span class="line">│         │       └── example</span><br><span class="line">│         │           └── plugin</span><br><span class="line">│         │               └── GreetingPlugin.groovy</span><br><span class="line">│         ├── resources</span><br><span class="line">│               └── META-INF</span><br><span class="line">│                     └── gradle-plugins</span><br><span class="line">│                           └── gretting.properties</span><br><span class="line">└── build.gradle</span><br></pre></td></tr></table></figure>
<p>在 gretting.properties 指定 plugin 实现类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation-class&#x3D;com.example.plugin.GreetingPlugin</span><br></pre></td></tr></table></figure>
<p>最终打包上传 jar，跟 spring-boot plugin 一样，在 buildscript # dependencies，使用 classpath 引入依赖<br>然后在 apply plugin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &quot;gretting&quot; &#x2F;&#x2F;这里使用 properties 文件的名称，去掉 properties 后缀</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h3 id="8-gradle-生命周期"><a href="#8-gradle-生命周期" class="headerlink" title="8. gradle 生命周期"></a>8. gradle 生命周期</h3><p>gradle 自身是有生命周期的，分为3个阶段。</p>
<ol>
<li><p>初始化阶段<br>加载 settings.gradle 文件并执行，这一阶段就清楚的知道当前项目一共有多少个模块（project）</p>
</li>
<li><p>配置阶段<br>前面说了，每个 build.gradle 文件对应一个 project 对象，那么这一阶段就会执行 build.gradle 中的代码，包括 task#configure 方法</p>
</li>
<li><p>执行阶段<br>在配置阶段就能确定了 task 之间的依赖关系，根据 gradle 命名行参数决定执行哪个 task</p>
</li>
</ol>
<h4 id="知道-gradle-生命周期-有什么用呢？"><a href="#知道-gradle-生命周期-有什么用呢？" class="headerlink" title="知道 gradle 生命周期 有什么用呢？"></a>知道 gradle 生命周期 有什么用呢？</h4><p>在 gradle 对象（ project#getGradle() 获取）中定义了各种钩子函数，project 对象也定义两个钩子函数 beforeEvaluate，afterEvaluate。<br>gradle 钩子函数</p>
<ol>
<li>buildStarted </li>
<li>beforeSettings</li>
<li>settingsEvaluated</li>
<li>projectsLoaded</li>
<li>beforeProject</li>
<li>projectsEvaluated</li>
<li>afterProject</li>
<li>buildFinished</li>
<li>其中还包括各种 Listener</li>
</ol>
<p>project 钩子函数  </p>
<ol>
<li><p>beforeEvaluate: 在执行 project 配置之前执行。它必须在父级以上的 project 来配置。<br>因为直接配置自己的 build.gradle，执行 build.gradle 已经是在 Evaluate ing 了，所以为了能在 Evaluate 之前，需要写到 parent project 上。<br>其实这个用的很少。</p>
</li>
<li><p>beforeEvaluate: 在执行 project 配置之后执行。这个方法对于插件开发来说就非常有用了。  </p>
</li>
</ol>
<hr>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/userguide.html">gradle 官方文档</a><br><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/java_plugin.html">gradle java plugin</a><br><a target="_blank" rel="noopener" href="https://docs.gradle.org/current/userguide/build_lifecycle.html">Build Lifecycle</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/gradle/" rel="tag"># gradle</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/gradle-plugin-action/" rel="prev" title="gradle plugin 实战">
                  <i class="fa fa-chevron-left"></i> gradle plugin 实战
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/k8s-graceful-shutdown/" rel="next" title="在 k8s 环境中如何优雅关闭 server">
                  在 k8s 环境中如何优雅关闭 server <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wang007</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

</body>
</html>
